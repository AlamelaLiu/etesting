<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Readme.4D05]]></title>
      <url>http://jarsonfang.github.io/etesting/D05/Deployment/Readme.4D05/</url>
      <content type="html"><![CDATA[<p>This is the readme file for D05 platform<br><a id="more"></a></p>
<p>After you executed <code>./estuary/build.sh --file=./estuary/estuarycfg.json --builddir=./workspace</code> for D05, all targets files will be produced. they are:</p>
<h3 id="UEFI-D05-fd"><a href="#UEFI-D05-fd" class="headerlink" title="UEFI_D05.fd"></a>UEFI_D05.fd</h3><p><strong>description</strong>: UEFI_D05.fd is the UEFI bios for D05 platform.</p>
<p><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/D05/UEFI_D05.fd</code></p>
<p><strong>source</strong>: <code>&lt;project root&gt;/uefi</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-uefi.sh --platform=D05 --output=workspace</div></pre></td></tr></table></figure></p>
<h3 id="grubaa64-efi"><a href="#grubaa64-efi" class="headerlink" title="grubaa64.efi"></a>grubaa64.efi</h3><p><strong>description</strong>:</p>
<p>grubaa64.efi is used to load kernel image and dtb files from SATA, SAS, USB Disk, or NFS into RAM and start the kernel.</p>
<p><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/arm64/grubaa64.efi</code></p>
<p><strong>source</strong>: <code>&lt;project root&gt;/grub</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):</p>
<p><code>./estuary/submodules/build-grub.sh --output=./workspace</code>, if your host is not arm architecture, please execute<code>build-grub.sh --output=./workspace --cross=aarch64-linux-gnu-</code></p>
<p>Note: more details about how to install gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.</p>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p><strong>descriptions</strong>: Image is the kernel executable program.</p>
<p><strong>target</strong>:</p>
<p>Image in <code>&lt;project root&gt;/workspace/binary/arm64/Image</code></p>
<p><strong>source</strong>: <code>&lt;project root&gt;/kernel</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):</p>
<p><code>./estuary/submodules/build-kernel.sh --platform=D05 --output=workspace</code>, if your host is not arm architecture, please execute <code>./estuary/submodules/build-kernel.sh --platform=D05 --output=workspace --cross=aarch64-linux-gnu-</code>.</p>
<p>Note: more details about how to install gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.</p>
<p>More detail about distributions, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guide.md</a>.</p>
<p>More detail about toolchains, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">Toolchains_Guide.md</a>.</p>
<p>More detail about how to deploy target system into D05 board, please refer to <a href="https://github.com/open-estuary/estuary/blob/estuary-d05-3.0b/doc/Deploy_Manual.4D05.md" target="_blank" rel="external">Deployment_Manual.md</a>.</p>
<p>More detail about how to debug, analyse, diagnose system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Armor_Manual.4All.md" target="_blank" rel="external">Armor_Manual.md</a>.</p>
<p>More detail about how to benchmark system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Caliper_Manual.4All.md" target="_blank" rel="external">Caliper_Manual.md</a>.</p>
<p>More detail about how to access remote boards in OpenLab, please refer to <a href="http://open-estuary.org/accessing-boards-in-open-lab/" target="_blank" rel="external">Boards_in_OpenLab</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Grub_Manual.4All]]></title>
      <url>http://jarsonfang.github.io/etesting/D05/Deployment/Grub_Manual.4All/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Grub config file</a></li>
<li><a href="#3">files structure bootable partition</a></li>
<li><a href="#4">FAQ</a></li>
</ul>
<a id="more"></a>
<h2 id="1">Introduction</h2>

<p>Grub is a kind of boot loader to load kernel into RAM and run it.</p>
<p>After rebooting board every time, the UEFI will firstly try to download the grub binary and run it firstly.</p>
<p>Then grub binary will load the kernel and start it with cmdline and dtb file according to the configurations in grub.cfg.</p>
<p>They include:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grubaa64.efi    <span class="comment"># The grub binary executable program for ARM64 architecture</span></div><div class="line">grubarm32.efi   <span class="comment"># The grub binary executable program for ARM32 architecture</span></div><div class="line">grub.cfg        <span class="comment"># The grub config file which will be used by grub binary</span></div></pre></td></tr></table></figure></p>
<p>Where to get them, please refer to Readme.txt.</p>
<h2 id="2">Grub config file</h2>

<p>You can edit a grub.cfg file to support various boot mode or multi boot partitions, follow is an example.</p>
<p>You should change them acoording to your real local environment.</p>
<p><strong><em>Note: D05 only supports booting system via ACPI mode with Centos.</em></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#</span></div><div class="line">    <span class="comment"># Sample GRUB configuration file</span></div><div class="line">    <span class="comment">#</span></div><div class="line"></div><div class="line">    <span class="comment"># Boot automatically after 0 secs.</span></div><div class="line">    <span class="built_in">set</span> timeout=5</div><div class="line"></div><div class="line">    <span class="comment"># By default, boot the Euler/Linux</span></div><div class="line">    <span class="built_in">set</span> default=d05_centos_nfs_acpi</div><div class="line"></div><div class="line"></div><div class="line">    menuentry <span class="string">"D05 minilinux PXE(ACPI)"</span> --id d05_minilinux_pxe_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 ip=dhcp</div><div class="line">    initrd /mini-rootfs-arm64.cpio.gz</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    menuentry <span class="string">"D05 Centos NFS(ACPI)"</span> --id d05_centos_nfs_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/hisilicon/ftp/centos ip=dhcp</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    menuentry <span class="string">"D05 Centos SATA(ACPI)"</span> --id d05_centos_sata_acpi&#123;</div><div class="line">    search --no-floppy --fs-uuid --set=root &lt;UUID&gt;</div><div class="line">    linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 root=PARTUUID=&lt;PARTUUID&gt; rootwait rootfstype=ext4 rw ip=dhcp</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from PXE with mini rootfs</span></div><div class="line">    menuentry <span class="string">"D03 minilinux PXE"</span> --id d03_minilinux_pxe &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off crashkernel=256M@32M rdinit=/init console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp</div><div class="line">    initrd /mini-rootfs-arm64.cpio.gz</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    menuentry <span class="string">"D03 Ubuntu NFS"</span> --id d03_ubuntu_nfs &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from SATA with Ubuntu rootfs in /dev/sda2</span></div><div class="line">    menuentry <span class="string">"D03 Ubuntu SATA"</span> --id d03_ubuntu_sata &#123;</div><div class="line">    <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off root=/dev/sda2 rootfstype=ext4 rw console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    menuentry <span class="string">"D03 minilinux PXE(ACPI)"</span> --id d03_minilinux_pxe_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off crashkernel=256M@32M rdinit=/init console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp acpi=force</div><div class="line">    initrd /mini-rootfs-arm64.cpio.gz</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    menuentry <span class="string">"D03 Ubuntu NFS(ACPI)"</span> --id d03_ubuntu_nfs_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp acpi=force</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    menuentry <span class="string">"D03 Ubuntu SATA(ACPI)"</span> --id d03_ubuntu_sata_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off root=/dev/sda2 rootfstype=ext4 rw console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp acpi=force</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Booting from eMMC with mini rootfs</span></div><div class="line">    menuentry <span class="string">"HiKey minilinux eMMC"</span> --id HiKey_minilinux_eMMC &#123;</div><div class="line">    linux /Image_HiKey rdinit=/init console=tty0 console=ttyAMA3,115200 rootwait rw loglevel=8 efi=noruntime</div><div class="line">    initrd /mini-rootfs.cpio.gz</div><div class="line">    devicetree /hi6220-hikey.dtb</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from eMMC with Ubuntu</span></div><div class="line">    menuentry <span class="string">"HiKey Ubuntu eMMC"</span> --id HiKey_Ubuntu_eMMC &#123;</div><div class="line">    linux /Image_HiKey rdinit=/init console=tty0 console=ttyAMA3,115200 root=/dev/mmcblk0p9 rootwait rw loglevel=8 efi=noruntime</div><div class="line">    devicetree /hi6220-hikey.dtb</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from SD card with Ubuntu</span></div><div class="line">    menuentry <span class="string">"HiKey Ubuntu SD card"</span> --id HiKey_Ubuntu_SD &#123;</div><div class="line">    linux /Image_HiKey rdinit=/init console=tty0 console=ttyAMA3,115200 root=/dev/mmcblk1p1 rootwait rw loglevel=8 efi=noruntime</div><div class="line">    devicetree /hi6220-hikey.dtb</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    menuentry <span class="string">'HiKey Fastboot mode'</span> &#123;</div><div class="line">    chainloader (hd0,gpt6)/fastboot.efi</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from PXE with mini rootfs</span></div><div class="line">    menuentry <span class="string">"D02 minilinux PXE"</span> --id d02_minilinux_pxe &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off crashkernel=256M@32M console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp</div><div class="line">    initrd /mini-rootfs.cpio.gz</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from NFS with Ubuntu rootfs</span></div><div class="line">    menuentry <span class="string">"D02 Ubuntu NFS"</span> --id d02_ubuntu_nfs &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from SATA with Ubuntu rootfs in /dev/sda2</span></div><div class="line">    menuentry <span class="string">"D02 Ubuntu SATA"</span> --id d02_ubuntu_sata &#123;</div><div class="line">    <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off root=/dev/sda2 rootfstype=ext4 rw console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from SATA with Fedora rootfs in /dev/sda3</span></div><div class="line">    menuentry <span class="string">"D02 Fedora SATA"</span> --id d02_fedora_sata &#123;</div><div class="line">    <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off root=/dev/sda3 rootfstype=ext4 rw console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from PXE with mini rootfs</span></div><div class="line">    menuentry <span class="string">"D02 minilinux PXE(ACPI)"</span> --id d02_minilinux_pxe_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off crashkernel=256M@32M console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp acpi=force</div><div class="line">    initrd /mini-rootfs.cpio.gz</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="comment"># Booting from NFS with Ubuntu rootfs</span></div><div class="line">    menuentry <span class="string">"D02 Ubuntu NFS(ACPI)"</span> --id d02_ubuntu_nfs_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp acpi=force</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment"># Booting from SATA with Ubuntu rootfs in /dev/sda2</span></div><div class="line">   menuentry <span class="string">"D02 Ubuntu SATA(ACPI)"</span> --id d02_ubuntu_sata_acpi &#123;</div><div class="line">   <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">   linux /Image rdinit=/init pcie_aspm=off root=/dev/sda2 rootfstype=ext4 rw console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp acpi=force</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment"># Booting from Norflash with mini rootfs</span></div><div class="line">   menuentry <span class="string">"D01 minilinux Norflash"</span> --id d01_minilinux_nor &#123;</div><div class="line">   devicetree (hd0,msdos1)/hip04<span class="_">-d</span>01.dtb</div><div class="line">   linux (hd0,msdos1)/zImage_D01 console=ttyS0,115200 earlyprintk initrd=0x10d00000,0x1800000 rdinit=/linuxrc ip=dhcp</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment"># Booting from SATA with Ubuntu rootfs in /dev/sda4</span></div><div class="line">   menuentry <span class="string">"D01 Ubuntu SATA"</span> --id d01_ubuntu_sata &#123;</div><div class="line">   devicetree (hd0,msdos1)/hip04<span class="_">-d</span>01.dtb</div><div class="line">   linux (hd0,msdos1)/zImage_D01 console=ttyS0,115200 earlyprintk root=/dev/sda4 rootfstype=ext4 rw ip=dhcp</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment"># Booting from SATA with OpenSuse rootfs in /dev/sda5</span></div><div class="line">   menuentry <span class="string">"D01 OpenSuse"</span> --id d01_opensuse_sata &#123;</div><div class="line">   devicetree (hd0,msdos1)/hip04<span class="_">-d</span>01.dtb</div><div class="line">   linux (hd0,msdos1)/zImage_D01 console=ttyS0,115200 earlyprintk root=/dev/sda5 rootfstype=ext4 rw ip=dhcp</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment"># Booting from NFS with Ubuntu rootfs</span></div><div class="line">   menuentry <span class="string">"D01 Ubuntu NFS"</span> --id d01_ubuntu_nfs &#123;</div><div class="line">   devicetree (hd0,msdos1)/hip04<span class="_">-d</span>01.dtb</div><div class="line">   linux (hd0,msdos1)/zImage_D01 console=ttyS0,115200 earlyprintk rootfstype=nfsroot root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu32 ip=dhcp</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Note: You should only select the parts from above sample which are suitable for your real situation.</p>
<h2 id="3">files structure bootable partition</h2>

<p>Normally they are placed into bootable partition as following structure.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-------EFI</div><div class="line">|       |</div><div class="line">|       GRUB2------grubaa64.efi   <span class="comment"># grub binary file only for ARM64 architecture</span></div><div class="line">|           |</div><div class="line">|           |</div><div class="line">|            ------grubarm32.efi  <span class="comment"># grub binary file only for ARM32 architecture</span></div><div class="line">|</div><div class="line">|-------------grub.cfg          <span class="comment"># grub config file</span></div><div class="line">|</div><div class="line">|-------------Image         <span class="comment"># kernel Image file only for D02 platform</span></div><div class="line"></div><div class="line">|-------------zImage_D01        <span class="comment"># kernel zImage file only for D01 platform</span></div><div class="line">|</div><div class="line">|-------------hip04<span class="_">-d</span>01.dtb     <span class="comment"># kernel data tree binary file only for D01 platform</span></div></pre></td></tr></table></figure></p>
<p>Note: In case of booting by PXE mode:</p>
<ol>
<li><p>The grub binary and grub.cfg files must be placed in the TFTP root directory.</p>
</li>
<li><p>The names and positions of kernel image and dtb must be consistent with the corresponding grub config file.</p>
</li>
<li><p>The grub binary name (grubxxx.efi) must be consistent with the “filename” in /etc/dhcp/dhcpd.conf, for more detail, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a></p>
</li>
<li><p>If you use D02 board, you should not input DTB in the grub.cfg but you must flash the DTB file into spiflash to avoid a known Mac address duplicate issue.</p>
<p>You can get more information from the Deploy_Manual.md guide.</p>
</li>
</ol>
<h2 id="4">FAQ</h2>

<p>If you want to modify grub.cfg command line temporarily. Type “E” key into grub modification menu. You will face problem that the “backspace” key not woking properly. You can fix backspace issue by changing terminal emulator’s configuration.</p>
<p><strong>For gnome-terminal</strong>: Open “Edit” menu, select “Profile preferences”.</p>
<p>In “Compatibility” page, select “Control-H” in “Backspace key generates” listbox.</p>
<p><strong>For Xterm</strong>: press Ctrl key and left botton of mouse, and toggle on “Backarrow key (BS/DEL)” in mainMenu.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UEFI_Manual.4D05]]></title>
      <url>http://jarsonfang.github.io/etesting/D05/Deployment/UEFI_Manual.4D05/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Upgrade UEFI</a></li>
<li><a href="#3">Recover the UEFI when it broke</a></li>
</ul>
<a id="more"></a>
<h2 id="1">Introduction</h2>

<p>UEFI is a kind of BIOS to boot system and provide runtime service to OS which can do some basic IO operation with the runtime service, e.g.: reboot, powe off and etc.<br>Normally, there are some trust firmware will be produce from UEFI building, they are responsible for trust reprogram, they include:</p>
<p>  UEFI_D05.fd         //UEFI executable binary file.</p>
<p>  CH02TEVBC_V03.bin   //CPLD binary to control power supplier.</p>
<p>Where to get them, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D05.md" target="_blank" rel="external">Readme.md</a>.</p>
<h2 id="2">Upgrade UEFI</h2>

<p>Note: This is not necessary unless you want to upgrade UEFI really.</p>
<ul>
<li><p>Prepare files about UEFI on local computer</p>
<p>FTP protocol is used for downloading between hardware boards and local network. Aboveall, please make sure you have a working FTP server in local network, so that board can get needed files from network by FTP.</p>
<p>All files mentioned above should be ready firstly, then put them in the root directory of FTP.</p>
</li>
<li><p>Connect the board’s UART port to a host machine</p>
<p>Please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Deploy_Manual.4D05.md" target="_blank" rel="external">Deploy_Manual.4D05.md</a> “Prerequisite” chapter.</p>
<p>If you choose Method 1, use another console window, use <code>board_reboot</code> command to reset the board.</p>
<p>If you choose Method 2, press the reset key on the board to reset the board.</p>
<p>when system showing “Press Any key in 10 seconds to stop automatical booting…”, press any key except “enter” key to enter UEFI main menu.</p>
</li>
<li><p>UEFI menu introduction</p>
<p>UEFI main menu option is showed as follow:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">continue</span></div><div class="line">select Language            &lt;standard English&gt;</div><div class="line">&gt;Boot Manager</div><div class="line">&gt;Device Manager</div><div class="line">&gt;Boot Maintenance Manager</div></pre></td></tr></table></figure>
<p>Choose “Boot Manager” and enter into Boot option menu:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">EFI Misc Device</div><div class="line">EFI Network</div><div class="line">EFI Network 1</div><div class="line">EFI Network 2</div><div class="line">EFI Network 3</div><div class="line">EFI Internal Shell</div><div class="line">ESL Start OS</div><div class="line">Embedded Boot Loader(EBL)</div></pre></td></tr></table></figure>
<p>D05 board support 4 on-board network ports at maximun. To enable any one of them by connecting to network cable or optical fiber. From left to right, followed by the two 2GE ports, two 10GE ports which corresponding to UEFI startup interface are EFI Network 2, EFI Network 3, EFI Network 0, EFI Network 1.</p>
<p>EFI Internal Shell mode is a standard command shell in UEFI.</p>
<p>Embedded Boot Loader(EBL) mode is an embedded command shell based on boot loader specially for developers.</p>
<p>You can switch between two modes by typing “exit” from one mode to UEFI main menu and then choose the another mode.</p>
</li>
<li><p>Update UEFI files</p>
<p>a. IP address config at “EFI Internal Shell” mode(Optional, you can ignore this step if DHCP works well)</p>
<p>Press any key except “enter” key to enter UEFI main menu. Select “Boot Manager”-&gt;”EFI Internal Shell”.</p>
<p><code>ifconfig -s eth0 static &lt;IP address&gt; &lt;mask&gt; &lt;gateway&gt;</code></p>
<p>e.g.:</p>
<p><code>ifconfig -s eth0 static 192.168.1.4 255.255.255.0 192.168.1.1</code></p>
<p>b. Burn BIOS file at “Embedded Boot Loader(EBL)” mode</p>
<p>Enter “exit” from “EFI Internal Shell” mode to the UEFI main menu and choose “Boot Manager”-&gt; “Embedded Boot Loader(EBL)”after setting the IP address done.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;UEFI binary&gt; <span class="_">-a</span> &lt;download target address&gt;</div><div class="line"><span class="comment"># Write the data into NORFLASH</span></div><div class="line">spiwfmem &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div></pre></td></tr></table></figure>
<p>e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> UEFI_D05.fd <span class="_">-a</span> 0x100000</div><div class="line">spiwfmem 0x100000 0x0000000 0x300000</div></pre></td></tr></table></figure>
<p>c. Power off and reboot board again.</p>
</li>
</ul>
<h2 id="3">Recover the UEFI when it broke</h2>

<p>Actually the board can restore two UEFI in case of the default one breaks, then you can restore it as following way:</p>
<ol>
<li>Power off the board and disconnect power supply.<br></li>
<li>Push the dial switch ‘s3’ to ‘off’ with a ‘3’ on the board, please check the Hardware Boards to find where it is: <a href="http://open-estuary.com/d05-2/" target="_blank" rel="external">http://open-estuary.com/d05-2/</a>.<br></li>
<li>Power on and enter UEFI SHELL again as above description.<br></li>
<li>Push the dial swift ‘s3’ to ‘on’ with a ‘3’ on the board.<br></li>
<li>Burn UEFI file for BIOS as above step3 “Update UEFI files”.<br></li>
<li>Reset the system again.</li>
</ol>
<p>Now you have already updated your failed BIOS, and the board will boot with new UEFI successfully.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Deploy_Manual.4D05]]></title>
      <url>http://jarsonfang.github.io/etesting/D05/Deployment/Deploy_Manual.4D05/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Preparation</a><ul>
<li><a href="#2.1">Prerequisite</a></li>
<li><a href="#2.2">Check the hardware board</a></li>
<li><a href="#2.3">Upgrade UEFI and trust firmware</a></li>
</ul>
</li>
<li><a href="#3">Bring up System via ACPI mode</a><ul>
<li><a href="#3.1">Boot via PXE(ACPI)</a></li>
<li><a href="#3.2">Boot via NFS(ACPI)</a></li>
<li><a href="#3.3">Boot via DISK(SAS/USB/SATA)(ACPI)</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="1">Introduction</h2>

<p>This documentation describes how to get, build, deploy and bring up target system based Estuary Project, it will help you to make your Estuary Environment setup from ZERO.</p>
<p>All following sections will take the D05 board as example, other boards have the similar steps to do, for more detail difference between them, please refer to Hardware Boards sections in <a href="http://open-estuary.com/hardware-boards/" target="_blank" rel="external">http://open-estuary.com/hardware-boards/</a>.</p>
<h2 id="2">Preparation</h2>

<h3 id="2.1">Prerequisite</h3>

<p>Local network: To connect hardware boards and host machine, so that they can communicate each other.</p>
<p>Serial cable: To connect hardware board’s serial port to host machine, so that you can access the target board’s UART in host machine.</p>
<p>Two methods are provided to <strong>connect the board’s UART port to a host machine</strong>:</p>
<p><strong>Method 1</strong> : connect the board’s UART in openlab environment</p>
<p> Use <code>board_connect</code> command.(Details please refer to <code>board_connect --help</code>)</p>
<p><strong>Method 2</strong> : directly connect the board by UART cable</p>
<p>   a. Connect the board’s UART port to a host machine with a serial cable.<br><br>   b. Install a serial port application in host machine, e.g.: kermit or minicom.<br><br>   c. Config serial port setting:115200/8/N/1 on host machine.<br></p>
<p>For more details, please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/UEFI_Manual.4D05.md" target="_blank" rel="external">UEFI_Manual.md</a><br>“Upgrade UEFI” chapter.</p>
<h3 id="2.2">Check the hardware board</h3>

<p>Hardware board should be ready and checked carefully to make sure it is available, more detail information about different hardware board, please refer to <a href="http://open-estuary.org/d05/" target="_blank" rel="external">http://open-estuary.org/d05/</a>.</p>
<h3 id="2.3">Upgrade UEFI and trust firmware</h3>

<p>You can upgrade UEFI and trust firmware yourself based on FTP service, but this is not necessary. If you really want to do it, please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/UEFI_Manual.4D05.md" target="_blank" rel="external">UEFI_Manual.md</a>.</p>
<h2 id="3">Bring up System via ACPI mode</h2>

<p>There are several methods to bring up system, you can select following anyone fitting you to boot up.</p>
<p>D05 only supports booting via ACPI, not support DTS mode. Set the parameters as follow to boot via ACPI.</p>
<p>You must add <code>&quot;acpi=force&quot;</code> property in <code>&quot;linux=....&quot;</code> line for “grub.cfg” file.</p>
<p>e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Booting from NFS with Centos rootfs</span></div><div class="line"> menuentry <span class="string">"D05 Centos NFS(ACPI)"</span> --id d05_centos_nfs_acpi &#123;</div><div class="line"><span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/hisilicon/ftp/centos ip=dhcp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NOTE: you can get more information about setting grub.cfg from <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</p>
<h3 id="3.1">Boot via PXE(ACPI)</h3>

<p>In this boot mode, the UEFI will get grub from PXE server.The grub will get the configuration file from TFTP service configured by PXE server.</p>
<ol>
<li><p>Setup PXE environment on host</p>
<p>Enable both DHCP and TFTP services on one of your host machines according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a>.</p>
</li>
<li><p>Reboot and press anykey except “enter” to enter UEFI Boot Menu</p>
</li>
<li><p>Select boot option “Boot Manager”-&gt;”EFI Network <code>&lt;No&gt;</code>“ boot option and press “Enter”.</p>
<p>Note:</p>
<p>If you are connecting the D05 board of openlab, please select “EFI Network 2”.</p>
<p>The value of <code>&lt;No&gt;</code> is depended on which D05 GE port is connected. D05 board support 4 on-board network ports at maximun.To enable any one of them by connecting to network cable or optical fiber. From left to right, followed by two GE ports, two 10GE ports which corresponding to UEFI startup interface are EFI Network 2, EFI Network 3, EFI Network 0, EFI Network 1.</p>
</li>
<li><p>After several seconds, D05 will boot by PXE automatically.</p>
</li>
</ol>
<p>To config the grub.cfg to support PXE boot, please refer to  <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</p>
<h3 id="3.2">Boot via NFS(ACPI)</h3>

<p>In this boot mode, the root parameter in grub.cfg menuentry will set to /dev/nfs and nfsroot will be set to the path of rootfs on NFS server. You can use <code>&quot;showmount -e &lt;server ip address&gt;&quot;</code>to list the exported NFS directories on the NFS server.</p>
<p>D05 supports booting via NFS, you can try it as following steps:</p>
<ol>
<li><p>Enable DHCP, TFTP and NFS service according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a>.</p>
</li>
<li><p>Get and config grub file to support NFS boot according to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</p>
<p>Note: D05 only supports booting via ACPI mode with Centos distribution, so please refer to Grub_Manual.md to get correct configuration.</p>
</li>
<li><p>Reboot D05 and press anykey except “enter” to enter UEFI Boot Menu</p>
</li>
<li><p>Select boot option “Boot Manager”-&gt;”EFI Network <code>&lt;No&gt;</code>“ boot option to enter.</p>
<p>Note:<br>If you are connecting the D05 board of openlab, please select “EFI Network 2”. The value of <code>&lt;No&gt;</code> is depended on which D05 GE port is connected.</p>
</li>
</ol>
<h3 id="3.3">Boot via DISK(SAS/USB/SATA)(ACPI)</h3>

<p>D05 board supports booting via SAS, USB and SATA by default. The UEFI will directly get the grub from the EFI system partition on the hard disk. The grub will load the grub configuration file from the EFI system partition. So grubaa64.efi, grub.cfg, Image and different estuary release distributions are stored on disk.</p>
<ol>
<li><p>Boot by PXE (please refer to “Boot via PXE”) to part and format hardware disk before booting D05 board</p>
<p>Format hardware disk</p>
<p>e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkfs.vfat /dev/sda1</div><div class="line">sudo mkfs.ext4 /dev/sda2</div></pre></td></tr></table></figure>
<p>Part hardware disk with <code>&quot;sudo fdisk /dev/sda&quot;</code> as follow:<br><br>add a gpt to this disk :</p>
<p><code>fdisk /dev/sda</code></p>
<p><code>g</code>——-add a gpt partition</p>
<p>add some EFI partition :</p>
<p><code>n</code>——-add a partition</p>
<p><code>1</code>——-the number of partition</p>
<p>type “Enter” key —— First sector</p>
<p><code>+200M</code>———Last sector, size of partition</p>
<p><code>t</code>——-change the type of partition</p>
<p>EFI system</p>
<p>add some another partition  <code>...</code><br><br>save the change           : <code>w</code><br><br>format EFI partition  : <code>sudo mkfs.vfat /dev/sda1</code><br><br>format ext4 partition : <code>sudo mkfs.ext4 /dev/sda2</code><br></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| Name    |   Size    |    Type      |   USB/SAS/SATA   |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda1    |   200M    |  EFI system  |   EFI            |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda2    |   10G     |    ext4      | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda3    |   10G     |    ext4      | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda4    |   10G     |    ext4      | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda5    |rest space |    ext4      | linux swap       |</div><div class="line">+---------+-----------+--------------+------------------+</div></pre></td></tr></table></figure>
<p>Note: EFI partition must be a fat filesystem, so you should format sda1 with <code>“sudo mkfs.vfat /dev/sda1″</code>.</p>
</li>
<li><p>Download files and store them into hardware disk as below.</p>
<p>(SAS/USB/SATA)Related files are placed as follow:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sda1: -------EFI</div><div class="line">       |       |</div><div class="line">       |       GRUB2------grubaa64.efi  //grub binary file</div><div class="line">       |</div><div class="line">       |-------------grub.cfg           //grub config file</div><div class="line">       |</div><div class="line">       |-------------Image          //kernel binary Image</div><div class="line"> sda2: Centos distribution</div></pre></td></tr></table></figure>
<p>Note: D05 only supports booting system with Centos, so Centos distribution should be uncompressed in sda2. The grubaa64.efi file must be put in /EFI/GRUB2 directory of dev/sda1(gpt partition)</p>
<p>To get kernel image file, please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Readme.4D05.md" target="_blank" rel="external">Readme.md</a>.<br><br>To get and config grub and grub.cfg, please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.<br><br>To get Centos distribution, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guider</a>.<br></p>
</li>
<li><p>Boot the board via SAS/USB/SATA</p>
<p>a. Modify grub config file, please refer to <a href="https://github.com/open-estuary/estuary/blob/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.4All.md</a><br><br>e.g.: <br></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Sample GRUB configuration file</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Boot automatically after 5 secs.</span></div><div class="line"><span class="built_in">set</span> timeout=5</div><div class="line"><span class="comment"># By default, boot the Estuary with Centos filesystem</span></div><div class="line"><span class="built_in">set</span> default=d05_centos_sata_acpi</div><div class="line"><span class="comment"># For booting GNU/Linux</span></div><div class="line"></div><div class="line">menuentry <span class="string">"D05 Centos SATA(ACPI)"</span> --id d05_centos_sata_acpi &#123;</div><div class="line">search --no-floppy --fs-uuid --set=root &lt;UUID&gt;</div><div class="line">linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 root=PARTUUID=&lt;PARTUUID&gt; rootwait rootfstype=ext4 rw ip=dhcp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Note:<br><br><code>&lt;UUID&gt;</code>means the UUID of that partition which your EFI System is located in.<br><br><code>&lt;PARTUUID&gt;</code> means the PARTUUID of that partition which your linux distribution is located in. <br><br> To see the values of UUID and PARTUUID, please use the command: <code>$blkid</code>.<br></p>
<p>b. Reboot and press anykey except “enter” to enter UEFI main menu.</p>
<p>c. For USB: Select “Boot Manager”-&gt; “EFI USB Device”-&gt; to enter grub selection menu.</p>
<p>For SAS: Select “Boot Manager”-&gt; “EFI Misc Device 1” to enter grub selection menu.</p>
<p>For SATA: Select “Boot Manager”-&gt; “EFI Hard Drive” to enter grub selection menu.</p>
<p>d. Press arrow key up or down to select grub boot option to decide which distribution should boot.</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Quick_Deployment.4D05]]></title>
      <url>http://jarsonfang.github.io/etesting/D05/Deployment/Quick_Deployment.4D05/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Quick Deploy System</a><ul>
<li><a href="#2.1">Deploy system via USB Disk</a></li>
<li><a href="#2.2">Deploy system via DVD/BMC</a></li>
<li><a href="#2.3">Deploy system via PXE</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="1">Introduction</h2>

<p>Above all, prepare hardware boards with SCSI disk and download Estuary source code from GitHub.<br>To learn more about how to do them, please visit this web site: <a href="http://open-estuary.com/estuary-user-manual/" target="_blank" rel="external">http://open-estuary.com/estuary-user-manual/</a>, and then refer to ‘Get &amp; Build Estuary yourself’.<br>Note: In my case, the working directory is <code>~/workdir</code>.</p>
<h2 id="2">Quick Deploy System</h2>

<h3 id="2.1">Deploy system via USB Disk</h3>

<ol>
<li><p>Prepare usb install disk.</p>
<ul>
<li><p>Modify estuary/estuarycfg.json. Make sure the platform, distros are all right.</p>
</li>
<li><p>Change the value of “install” to “yes” in object “setup” for usb and the value “device” to your USB install disk.<br>(Notice: if the specified usb device does not exist, the first usb device will be selected by default.)</p>
</li>
<li><p>Use build.sh to create the usb install disk.</p>
<p> eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code></p>
</li>
</ul>
</li>
<li><p>Connect the usb install disk to the board.</p>
</li>
<li><p>Reboot the board.</p>
</li>
<li><p>Boot from the usb device. (About how to boot from USB device, please refer to the UEFI related manual.)</p>
</li>
<li><p>According to the prompt to deploy the system.</p>
</li>
<li><p>Start the boards from “grub” menu of UEFI by default.</p>
</li>
</ol>
<h3 id="2.2">Deploy system via DVD/BMC</h3>

<ol>
<li><p>Prepare ISO image and install disk.</p>
<ul>
<li><p>Modify estuary/estuarycfg.json. Make sure the platform, distros are all right.</p>
</li>
<li><p>Change the value of “install” to “yes” in object “setup” for iso and the value “name” to your target iso image file name.</p>
</li>
<li><p>Use build.sh to create the target install iso image file.</p>
<p> eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code></p>
</li>
</ul>
</li>
<li><p>Via DVD</p>
<ul>
<li><p>Burn the iso image file to DVD disk if you use the physical DVD driver.</p>
</li>
<li><p>Connect the physical DVD driver to the board, plug in the install DVD disk.</p>
</li>
<li><p>Reboot the board.</p>
</li>
<li><p>Boot from the DVD device. (About how to boot from DVD device, please refer to the UEFI related manual.)</p>
</li>
<li><p>According to the prompt to deploy the system.</p>
</li>
<li><p>Start the boards from “grub” menu of UEFI by default.</p>
</li>
</ul>
</li>
<li><p>Via BMC</p>
<ul>
<li><p>Login BMC website of specified IP with browser(IE browser is suggested to use), The <code>username</code> &amp; <code>password</code> is <code>root</code> &amp; <code>Huawei12#$</code>.</p>
</li>
<li><p>Click “Remote” on the top of BMC webiste. Select “Remote Virtual Console (Private Mode)” to enter into KVM interface. Click “Image File” and choose the iso image, then click “Connect” button.</p>
</li>
<li><p>Click “Config” on the top of BMC website, click “Boot Option” to select “DVD-ROM drive”, then click “Save” button.</p>
</li>
<li><p>Reboot the board</p>
</li>
<li><p>According to the prompt to deploy the system.</p>
</li>
</ul>
</li>
</ol>
<h3 id="2.3">Deploy system via PXE</h3>

<ol>
<li><p>Connect Ubuntu PC and hardware boards into the same local area network. (Make sure the PC can connect to the internet and no other PXE servers exist.)</p>
</li>
<li><p>Modify the configuration file of estuary/estuarycfg.json based on you hardware boards. Change the values of mac to physical addresses of the connected network cards on the board. Change the value of “install” to “yes” in object “setup” for PXE.</p>
</li>
<li><p>Backup files under the tftp root directory if necessary. Use build.sh to bBMCd project and setup the PXE server on Ubuntu PC.</p>
<p>eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code></p>
</li>
<li><p>After that, install minicom and connect the serial ports of hardware boards to the Ubuntu PC. Connect the hardware boards by minicom using serial ports.</p>
</li>
<li><p>Reboot the hardware boards and start the boards from the correct EFI Network.</p>
</li>
<li><p>Install the system according to prompt. After install finished, the boards will restart automatically.</p>
</li>
<li><p>Start the boards from “grub” menu of UEFI by default.</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[awk 手册]]></title>
      <url>http://jarsonfang.github.io/etesting/sed-awk/awk/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简体中文版由bones7456 (<a href="http://li2z.cn)整理" target="_blank" rel="external">http://li2z.cn)整理</a>.<br>原文:应该是 <a href="http://phi.sinica.edu.tw/aspac/reports/94/94011/" target="_blank" rel="external">http://phi.sinica.edu.tw/aspac/reports/94/94011/</a> 但是原文很乱.<br>说明:之前也是对awk几乎一无所知,无意中看到这篇文章,网上一搜,居然没有像样的简体中文版.有的也是不怎么完整,或者错误一大堆的.于是就顺手整理了下这篇文章.通过整理这篇文章,自己也渐渐掌握了awk的种种用法.<br>原文可能比较老,有些目前已经不适用的命令有所改动,文中所有命令均在ubuntu7.04下调试通过,用的awk是mawk.<br>由于本人能力有限,错误和不妥之处在所难免,欢迎多多指正.  </p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="有关本手册"><a href="#有关本手册" class="headerlink" title="有关本手册"></a>有关本手册</h3><p>这是一本awk学习指引, 其重点着重于:</p>
<ol>
<li>awk 适于解决哪些问题?</li>
<li>awk 常见的解题模式为何?</li>
</ol>
<p>为使读者快速掌握awk解题的模式及特性, 本手册系由一些较具代表性的范例及其题解所构成; 各范例由浅入深, 彼此间相互连贯, 范例中并对所使用的awk语法及指令辅以必要的说明. 有关awk的指令, 函数, … 等条列式的说明则收录于附录中, 以利读者往后撰写程序时查阅. 如此编排, 可让读者在短时间内顺畅地学会使用awk来解决问题. 建议读者循着范例上机实习, 以加深学习效果.<br>读者宜先具备下列背景:<br>[a.] UNIX 环境下的简单操作及基本概念.<br>例如: 文件编辑, 文件复制及管道, 输入/输出重定向等概念<br>[b.] C 语言的基本语法及流程控制指令.<br>(awk 指令并不多, 且其中之大部分与C语言中之用法一致, 本手册中对该类指令之语法及特性不再加以繁冗的说明, 读者若欲深究,可自行翻阅相关的 C 语言书籍)</p>
<h2 id="awk概述"><a href="#awk概述" class="headerlink" title="awk概述"></a>awk概述</h2><h3 id="为什么使用awk"><a href="#为什么使用awk" class="headerlink" title="为什么使用awk"></a>为什么使用awk</h3><p>awk 是一种程序语言. 它具有一般程序语言常见的功能.<br>因awk语言具有某些特点, 如: 使用直译器(Interpreter)不需先行编译; 变量无类型之分(Typeless), 可使用文字当数组的下标(Associative Array)…等特色. 因此, 使用awk撰写程序比起使用其它语言更简洁便利且节省时间. awk还具有一些内建功能, 使得awk擅于处理具数据行(Record), 字段(Field)型态的资料; 此外, awk内建有pipe的功能, 可将处理中的数据传送给外部的Shell命令加以处理, 再将Shell命令处理后的数据传回awk程序, 这个特点也使得awk程序很容易使用系统资源.<br>由于awk具有上述特色, 在问题处理的过程中, 可轻易使用awk来撰写一些小工具; 这些小工具并非用来解决整个大问题,它们只扮演解决个别问题过程的某些角色, 可藉由Shell所提供的pipe将数据按需要传送给不同的小工具进行处理, 以解决整个大问题. 这种解题方式, 使得这些小工具可因不同需求而被重复组合及重用(reuse); 也可藉此方式来先行测试大程序原型的可行性与正确性, 将来若需要较高的执行速度时再用C语言来改写.这是awk最常被应用之处. 若能常常如此处理问题, 读者可以以更高的角度来思考抽象的问题, 而不会被拘泥于细节的部份.<br>本手册为awk入门的学习指引, 其内容将先强调如何撰写awk程序,未列入进一步解题方式的应用实例, 这部分将留待UNIX进阶手册中再行讨论.</p>
<h3 id="如何取得awk"><a href="#如何取得awk" class="headerlink" title="如何取得awk"></a>如何取得awk</h3><p>一般的UNIX操作系统, 本身即附有awk. 不同的UNIX操作系统所附的awk其版本亦不尽相同. 若读者所使用的系统上未附有awk,可透过 anonymous ftp 到下列地方取得:<br>phi.sinica.edu.tw:/pub/gnu<br>ftp.edu.tw:/UNIX/gnu<br>prep.ai.mit.edu:/pub/gnu</p>
<h3 id="awk如何工作"><a href="#awk如何工作" class="headerlink" title="awk如何工作"></a>awk如何工作</h3><p>为便于解释awk程序架构, 及有关术语(terminology), 先以一个员工薪资档(emp.dat ), 来加以介绍.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A125 Jenny 100 210</div><div class="line">A341 Dan 110 215</div><div class="line">P158 Max 130 209</div><div class="line">P148 John 125 220</div><div class="line">A123 Linda 95 210</div></pre></td></tr></table></figure></p>
<p>文件中各字段依次为员工ID, 姓名, 薪资率, 及实际工时. ID中的第一码为部门识别码. “A”,”P” 分别表示”组装”及”包装”部门.<br>本小节着重于说明awk程序的主要架构及工作原理, 并对一些重要的名词辅以必要的解释. 由这部分内容, 读者可体会出awk语言的主要精神及awk与其它语程序言的差异处. 为便于说明, 以条列方式说明于后.</p>
<h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><p><strong>数据行</strong>: awk从数据文件上读取数据的基本单位.以上列文件emp.dat为例, awk读入的<br>第一笔数据行是 “A125 Jenny 100 210”<br>第二笔数据行是 “A341 Dan 110 215”<br>一般而言, 一个数据行就相当于数据文件上的一行资料. (参考 : 附录 B 内建变量”RS”)</p>
<p><strong>字段(Field)</strong>: 为数据行上被分隔开的子字符串.<br>以数据行”A125 Jenny 100 210”为例,<br>第一栏 第二栏 第三栏 第四栏 “A125” “Jenny” 100 210<br>一般是以空格符来分隔相邻的字段. (参考 : 附录 D 内建变量”FS”)</p>
<h2 id="如何执行awk"><a href="#如何执行awk" class="headerlink" title="如何执行awk"></a>如何执行awk</h2><p>于UNIX的命令行上键入诸如下列格式的指令: ( “<code>$</code>“ 表Shell命令行上的提示符号)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'awk程序'</span> 数据文件文件名</div></pre></td></tr></table></figure></p>
<p>则awk会先编译该程序, 然后执行该程序来处理所指定的数据文件.<br>(上列方式系直接把程序写在UNIX的命令行上)</p>
<h3 id="awk-程序的主要结构"><a href="#awk-程序的主要结构" class="headerlink" title="awk 程序的主要结构:"></a>awk 程序的主要结构:</h3><p>awk程序中主要语法是<code>Pattern { Actions }</code>, 故常见之awk程序其型态如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Pattern1 &#123; Actions1 &#125;</div><div class="line">Pattern2 &#123; Actions2 &#125;</div><div class="line">......</div><div class="line">Pattern3 &#123; Actions3 &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Pattern-是什么"><a href="#Pattern-是什么" class="headerlink" title="Pattern 是什么 ?"></a>Pattern 是什么 ?</h3><p>awk可接受许多不同型态的Pattern. 一般常使用”关系表达式”(Relational expression)来当成Pattern.<br>例如:<br><code>x &gt; 34</code> 是一个Pattern, 判断变量 <code>x</code> 与 <code>34</code> 是否存在大于的关系.<br><code>x == y</code> 是一个Pattern, 判断变量 <code>x</code> 与变量 <code>y</code> 是否存在等于的关系.<br>上式中<code>x &gt;34</code>,<code>x == y</code>便是典型的Pattern.</p>
<p>awk 提供 C 语言中常见的关系运算符(Relational Operators) 如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;, &lt;, &gt;=, &lt;=, ==, !=</div></pre></td></tr></table></figure></p>
<p>此外, awk 还提供 <code>~</code> (match) 及 <code>!~</code> (not match) 二个关系运算符(注一).<br>其用法与涵义如下:<br>若 A 为一字符串, B 为一正则表达式(Regular Expression)<br><code>A ~ B</code> 判断字符串 A 中是否 <em>包含</em> 能匹配(match) B 表达式的子字符串.<br><code>A !~ B</code> 判断字符串 A 中是否 <em>不包含</em> 能匹配(match) B 表达式的子字符串.<br>例如 :<br><code>&quot;banana&quot; ~ /an/</code> 整个是一个Pattern.<br>因为”<code>banana</code>“中含有可以匹配 <code>/an/</code> 的子字符串, 故此关系式成立(true),整个Pattern的值也是true.</p>
<p>相关细节请参考 附录 A Patterns, 附录 E Regular Expression</p>
<p>(注一:) 有少数awk论著, 把 <code>~,</code> <code>!~</code> 当成另一类的 Operator, 并不视为一种 Relational Operator. 本手册中将这两个运算符当成一种 Relational Operator.</p>
<h3 id="Actions-是什么"><a href="#Actions-是什么" class="headerlink" title="Actions 是什么?"></a>Actions 是什么?</h3><p>Actions 是由许多awk指令构成. 而awk的指令与 C 语言中的指令十分类似.<br>例如:<br>awk的I/O指令: <code>print, printf( ), getline...</code><br>awk的流程控制指令: <code>if(...){..} else{..}, while(...){...}...</code></p>
<p>(请参考 附录 B — “Actions” )</p>
<h3 id="awk-如何处理-Pattern-Actions"><a href="#awk-如何处理-Pattern-Actions" class="headerlink" title="awk 如何处理 Pattern { Actions } ?"></a>awk 如何处理 Pattern { Actions } ?</h3><p>awk 会先判断(Evaluate) 该 Pattern 的值, 若 Pattern 判断后的值为 true (或不为0的数字,或不是空的字符串), 则 awk 将执行该 Pattern 所对应的 Actions. 反之, 若 Pattern 之值不为 true, 则awk将不执行该 Pattern 所对应的 Actions.</p>
<p>例如 : 若awk程序中有下列两指令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">50 &gt; 23 &#123;<span class="built_in">print</span> <span class="string">"Hello! The word!!"</span> &#125;</div><div class="line"><span class="string">"banana"</span> ~ /123/ &#123; <span class="built_in">print</span> <span class="string">"Good morning !"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>awk会先判断<code>50 &gt;23</code>是否成立. 因为该式成立, 所以awk将印出”<code>Hello! The word!!</code>“. 而另一 Pattern 为<code>&quot;banana&quot; ~/123/</code>, 因为<code>&quot;banana&quot;</code>内未含有任何子字符串可<code>match /123/</code>, 该 Pattern 之值为false, 故awk将不会印出 “<code>Good morning !</code>“</p>
<h3 id="awk-如何处理-Actions-的语法-缺少Pattern部分"><a href="#awk-如何处理-Actions-的语法-缺少Pattern部分" class="headerlink" title="awk 如何处理{ Actions } 的语法? (缺少Pattern部分)"></a>awk 如何处理{ Actions } 的语法? (缺少Pattern部分)</h3><p>有时语法<code>Pattern { Actions }</code>中, <code>Pattern</code> 部分被省略, 只剩 <code>{Actions}</code>. 这种情形表示 “无条件执行这个Actions”.</p>
<h3 id="awk-的字段变量"><a href="#awk-的字段变量" class="headerlink" title="awk 的字段变量"></a>awk 的字段变量</h3><p>awk 所内建的字段变量及其涵意如下 :</p>
<table>
<thead>
<tr>
<th>字段变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$0</code></td>
<td>一字符串, 其内容为目前 awk 所读入的数据行.</td>
</tr>
<tr>
<td><code>$1</code></td>
<td><code>$0</code> 上第一个字段的数据.</td>
</tr>
<tr>
<td><code>$2</code></td>
<td><code>$0</code> 上第二个字段的数据.</td>
</tr>
<tr>
<td>…</td>
<td>其余类推</td>
</tr>
</tbody>
</table>
<h3 id="读入数据行时-awk如何更新-update-这些内建的字段变量"><a href="#读入数据行时-awk如何更新-update-这些内建的字段变量" class="headerlink" title="读入数据行时, awk如何更新(update)这些内建的字段变量?"></a>读入数据行时, awk如何更新(update)这些内建的字段变量?</h3><p>当 awk 从数据文件中读取一个数据行时, awk 会使用内建变量<code>$0</code>予以记录.每当<code>$0</code>被改动时 (例如 : 读入新的数据行或自行变更<code>$0</code>, …) awk 会立刻重新分析 <code>$0</code> 的字段情况, 并将 <code>$0</code> 上各字段的数据用 <code>$1</code>, <code>$2</code>, … 予以记录.</p>
<h3 id="awk的内建变量-Built-in-Variables"><a href="#awk的内建变量-Built-in-Variables" class="headerlink" title="awk的内建变量(Built-in Variables)"></a>awk的内建变量(Built-in Variables)</h3><p>awk 提供了许多内建变量, 使用者于程序中可使用这些变量来取得相关信息. 常见的内建变量有:</p>
<table>
<thead>
<tr>
<th>内建变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NF (Number of Fields)</td>
<td>为一整数, 其值表<code>$0</code>上所存在的字段数目.</td>
</tr>
<tr>
<td>NR (Number of Records)</td>
<td>为一整数, 其值表awk已读入的数据行数目.</td>
</tr>
<tr>
<td>FILENAME</td>
<td>awk 正在处理的数据文件文件名.</td>
</tr>
</tbody>
</table>
<p>例如: awk 从资料文件 emp.dat 中读入第一笔数据行<br>“<code>A125 Jenny 100 210</code>“ 之后, 程序中:<br><code>$0</code> 之值将是 “A125 Jenny 100 210”<br><code>$1</code> 之值为 “A125”<br><code>$2</code> 之值为 “Jenny”<br><code>$3</code> 之值为 100<br><code>$4</code> 之值为 210<br><code>$NF</code> 之值为 4<br><code>$NR</code> 之值为 1<br><code>$FILENAME</code> 之值为 “emp.dat”</p>
<h3 id="awk的工作流程"><a href="#awk的工作流程" class="headerlink" title="awk的工作流程"></a>awk的工作流程</h3><p>执行awk时, 它会反复进行下列四步骤.</p>
<ul>
<li>自动从指定的数据文件中读取一个数据行.</li>
<li>自动更新(Update)相关的内建变量之值. 如:<code>NF</code>,<code>NR</code>, <code>$0</code> …</li>
<li>依次执行程序中所有的<code>Pattern { Actions }</code>指令.</li>
<li>当执行完程序中所有<code>Pattern { Actions }</code>时, 若数据文件中还有未读取的数据, 则反复执行步骤1到步骤4.</li>
</ul>
<p>awk会自动重复进行上述4个步骤, 使用者不须于程序中编写这个循环 (Loop).</p>
<h3 id="打印文件中指定的字段数据并加以计算"><a href="#打印文件中指定的字段数据并加以计算" class="headerlink" title="打印文件中指定的字段数据并加以计算"></a>打印文件中指定的字段数据并加以计算</h3><p>awk 处理数据时, 它会自动从数据文件中一次读取一笔记录, 并会将该数据切分成一个个的字段; 程序中可使用<code>$1</code>, <code>$2</code>, … 直接取得各个字段的内容. 这个特色让使用者易于用 awk 编写 reformatter 来改变量据格式.</p>
<p>范例: 以文件 emp.dat 为例, 计算每人应发工资并打印报表.<br>分析: awk 会自行一次读入一列数据, 故程序中仅需告诉 awk 如何处理所读入的数据行.<br>执行如下命令: (<code>$</code>表UNIX命令行上的提示符)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'&#123; print $2, $3 * $4 &#125;'</span> emp.dat</div></pre></td></tr></table></figure></p>
<p>执行结果如下:<br>屏幕出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Jenny 21000</div><div class="line">Dan 23650</div><div class="line">Max 27170</div><div class="line">John 27500</div><div class="line">Linda 19950</div></pre></td></tr></table></figure></p>
<p>说明:<br>UNIX命令行上, 执行awk的语法为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'awk程序'</span> 欲处理的资料文件文件名</div></pre></td></tr></table></figure></p>
<p>本范例中的程序部分为<code>{print $2, $3 * $4}</code>. 把程序置于命令行时, 程序之前后须以<code>&#39;</code>括住. <code>emp.dat</code>为指定给该程序处理的数据文件文件名.</p>
<p>本程序中使用:<code>Pattern { Actions }</code>语法.<br>Pattern 部分被省略, 表无任何限制条件. 故 awk 读入每笔数据行后都将无条件执行这个 Actions.<br><code>print</code>为awk所提供的输出指令, 会将数据输出到stdout(屏幕).<br><code>print</code>的参数间彼此以”<code>,</code>“ (逗号) 隔开, 印出数据时彼此间会以空白隔开. (参考 附录 D 内建变量OFS)</p>
<p>将上述的程序部分储存于文件 <code>pay1.awk</code> 中. 执行命令时再指定awk程序文件之文件名. 这是执行awk的另一种方式, 特别适用于程序较大的情况, 其语法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> awk程序文件名 数据文件文件名</div></pre></td></tr></table></figure></p>
<p>故执行下列两命令,将产生同样的结果.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> pay1.awk emp.dat</div><div class="line">$ awk <span class="string">'&#123; print $2, $3 * $4 &#125;'</span> emp.dat</div></pre></td></tr></table></figure></p>
<p>读者可使用”<code>-f</code>“参数, 让awk主程序使用“其它仅含 awk 函数的文件中的函数”<br>其语法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> awk主程序文件名 <span class="_">-f</span> awk函数文件名 数据文件文件名</div></pre></td></tr></table></figure></p>
<p>(有关 awk 中函数的声明与使用于 7.4 中说明)</p>
<p>awk中也提供与 C 语言中类似用法的 <code>printf()</code> 函数. 使用该函数可进一步控制数据的输出格式.</p>
<p>编辑另一个awk程序如下, 并取名为 <code>pay2.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">printf</span>(<span class="string">"%6s Work hours: %3d Pay: %5d\n"</span>, <span class="variable">$2</span>,<span class="variable">$3</span>, <span class="variable">$3</span>* <span class="variable">$4</span>) &#125;</div></pre></td></tr></table></figure></p>
<p>执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> pay2.awk emp.dat</div></pre></td></tr></table></figure></p>
<p>执行结果屏幕出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Jenny Work hours: 100 Pay: 21000</div><div class="line">   Dan Work hours: 110 Pay: 23650</div><div class="line">   Max Work hours: 130 Pay: 27170</div><div class="line">  John Work hours: 125 Pay: 27500</div><div class="line"> Linda Work hours:  95 Pay: 19950</div></pre></td></tr></table></figure></p>
<h2 id="选择符合指定条件的记录"><a href="#选择符合指定条件的记录" class="headerlink" title="选择符合指定条件的记录"></a>选择符合指定条件的记录</h2><p><code>Pattern { Action }</code>为awk中最主要的语法. 若某Pattern之值为真则执行它后方的 Action. awk中常使用 “关系表达式”(Relational Expression) 来当成 Pattern.</p>
<p>awk 中除了<code>&gt;, &lt;, ==, !=</code>, … 等关系运算符( Relational Operators )外, 另外提供<code>~</code>(match),<code>!~</code>(Not Match)二个关系运算符. 利用这两个运算符, 可判断某字符串是否包含能匹配所指定正则表达式的子字符串. 由于这些特性, 很容易使用awk来编写需要字符串比对, 判断的程序.</p>
<p>范例: 承上例,<br>组装部门员工调薪5%,(组装部门员工之ID以”A”开头)<br>所有员工最后之薪资率若仍低于100, 则以100计.<br>编写awk程序打印新的员工薪资率报表.</p>
<p>分析: 这个程序须先判断所读入的数据行是否合于指定条件, 再进行某些动作. awk 中<code>Pattern { Actions }</code>的语法已涵盖这种”<code>if ( 条件) { 动作}</code>“的架构. 编写如下之程序, 并取名<code>adjust1.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span> ~ /^A.*/ &#123; <span class="variable">$3</span> *= 1.05 &#125; <span class="variable">$3</span>&lt;100 &#123; <span class="variable">$3</span> = 100 &#125;</div><div class="line">&#123; <span class="built_in">printf</span>(<span class="string">"%s %8s %d\n"</span>, <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span>)&#125;</div></pre></td></tr></table></figure></p>
<p>执行下列命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> adjust1.awk emp.dat</div></pre></td></tr></table></figure></p>
<p>结果如下 : 屏幕出现 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A125    Jenny 105</div><div class="line">A341      Dan 115</div><div class="line">P158      Max 130</div><div class="line">P148     John 125</div><div class="line">A123    Linda 100</div></pre></td></tr></table></figure></p>
<p>说明:<br>awk的工作程序是: 从数据文件中每次读入一个数据行, 依序执行完程序中所有的<code>Pattern{ Action }</code>指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span>~/^A.*/ &#123; <span class="variable">$3</span> *= 1.05 &#125;</div><div class="line"><span class="variable">$3</span> &lt; 100 &#123; <span class="variable">$3</span> = 100 &#125;</div><div class="line">&#123;<span class="built_in">printf</span>(<span class="string">"%s %8s %d\n"</span>,<span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>)&#125;</div></pre></td></tr></table></figure></p>
<p>再从数据文件中读进下一笔记录继续进行处理.<br>第一个<code>Pattern { Action }</code>是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span> ~ /^A.*/ &#123; <span class="variable">$3</span> *= 1.05 &#125;</div></pre></td></tr></table></figure></p>
<p><code>$1 ~ /^A.*/</code> 是一个Pattern, 用来判断该笔数据行的第一栏是否包含以”A”开头的子字符串. 其中 <code>/^A.*/</code> 是一个Regular Expression, 用以表示任何以”A”开头的字符串. (有关 Regular Expression 之用法 参考 附录 E).<br>Actions 部分为 <code>$3 *= 1.05</code><br><code>$3 *= 1.05</code>与<code>$3 = $3 * 1.05</code> 意义相同. 运算子”<code>*=</code>“之用法则与 C 语言中一样. 此后与 C 语言中用法相同的运算子或语法将不予赘述.</p>
<p>第二个 <code>Pattern { Actions }</code> 是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$3</span> &lt;100 &#123; <span class="variable">$3</span> = 100 &#125;</div></pre></td></tr></table></figure></p>
<p>若第三栏的数据内容(表薪资率)小于100, 则调整为100.</p>
<p>第三个<code>Pattern { Actions }</code>是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="built_in">printf</span>(<span class="string">"%s %8s %d\n"</span>,<span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span> )&#125;</div></pre></td></tr></table></figure></p>
<p>省略了Pattern(无条件执行Actions), 故所有数据行调整后的数据都将被印出.</p>
<h2 id="awk-中数组"><a href="#awk-中数组" class="headerlink" title="awk 中数组"></a>awk 中数组</h2><p>awk程序中允许使用字符串当做数组的下标(index). 利用这个特色十分有助于资料统计工作.(使用字符串当下标的数组称为Associative Array)</p>
<p>首先建立一个数据文件, 并取名为 <code>reg.dat</code>. 此为一学生注册的资料文件; 第一栏为学生姓名, 其后为该生所修课程.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mary O.S. Arch. Discrete</div><div class="line">Steve D.S. Algorithm Arch.</div><div class="line">Wang Discrete Graphics O.S.</div><div class="line">Lisa Graphics A.I.</div><div class="line">Lily Discrete Algorithm</div></pre></td></tr></table></figure></p>
<h3 id="awk中数组的特性"><a href="#awk中数组的特性" class="headerlink" title="awk中数组的特性"></a>awk中数组的特性</h3><p>使用字符串当数组的下标(index)，使用数组前不须宣告数组名及其大小.</p>
<p>例如: 希望用数组来记录 <code>reg.dat</code> 中各门课程的修课人数. 这情况,有二项信息必须储存:<br>(a) 课程名称, 如: “O.S.”, “Arch.” … ,共有哪些课程事先并不明确.<br>(b)各课程的修课人数. 如: 有几个人修”O.S.”<br>在awk中只要用一个数组就可同时记录上列信息. 其方法如下:</p>
<h4 id="使用一个数组Number"><a href="#使用一个数组Number" class="headerlink" title="使用一个数组Number[]"></a>使用一个数组Number[]</h4><p>以课程名称当<code>Number[]</code>的下标，以<code>Number[]</code>中不同下标所对映的元素代表修课人数.<br>例如:<br>有2个学生修”O.S.”, 则以<code>Number[&quot;O.S.&quot;] = 2</code>表之.<br>若修”O.S.”的人数增加一人, 则<code>Number[&quot;O.S.&quot;] = Number[&quot;O.S.&quot;] + 1</code> 或 <code>Number[&quot;O.S.&quot;]++</code> .</p>
<h4 id="如何取出数组中储存的信息"><a href="#如何取出数组中储存的信息" class="headerlink" title="如何取出数组中储存的信息"></a>如何取出数组中储存的信息</h4><p>以 C 语言为例, 声明 <code>int Arr[100];</code> 之后, 若想得知 <code>Arr[]</code> 中所储存的数据, 只须用一个循环, 如 :<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Arr[i]);</div></pre></td></tr></table></figure></p>
<p>即可. 上式中:<br>数组 <code>Arr[]</code> 的下标: <code>0, 1, 2,..., 99</code><br>数组 <code>Arr[]</code> 中各下标所对应的值: <code>Arr[0], Arr[1],...Arr[99]</code><br>但 awk 中使用数组并不须事先宣告. 以刚才使用的 <code>Number[]</code> 而言, 程序执行前, 并不知将来有哪些课程名称可能被当成 <code>Number[]</code> 的下标.</p>
<p>awk 提供了一个指令, 藉由该指令awk会自动找寻数组中使用过的所有下标. 以 <code>Number[]</code> 为例, awk将会找到”O.S.”, “Arch.”, …<br>使用该指令时, 须指定所要找寻的数组, 及一个变量. awk会使用该的变量来记录从数组中找到的每一个下标. 例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(course <span class="keyword">in</span> Number)&#123;....&#125;</div></pre></td></tr></table></figure></p>
<p>指定用 <code>course</code> 来记录 awk 从<code>Number[]</code> 中所找到的下标. awk每找到一个下标时, 就用<code>course</code>记录该下标之值且执行<code>{....}</code>中之指令. 藉由这个方式便可取出数组中储存的信息. (详见下例)<br>范例: 统计各科修课人数,并印出结果.<br>建立如下程序,并取名为<code>course.awk</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">for</span>( i=2; i &lt;= NF; i++) Number[<span class="variable">$i</span>]++ &#125;</div><div class="line">END&#123;<span class="keyword">for</span>(course <span class="keyword">in</span> Number) <span class="built_in">printf</span>(<span class="string">"%10s %d\n"</span>, course, Number[course] )&#125;</div></pre></td></tr></table></figure></p>
<p>执行下列命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> course.awk reg.dat</div></pre></td></tr></table></figure></p>
<p>执行结果如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Graphics 2</div><div class="line">      O.S. 2</div><div class="line">  Discrete 3</div><div class="line">      A.I. 1</div><div class="line">      D.S. 1</div><div class="line">     Arch. 2</div><div class="line"> Algorithm 2</div></pre></td></tr></table></figure></p>
<p>说明:<br>这程序包含二个<code>Pattern { Actions }</code>指令.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">for</span>( i=2; i &lt;= NF; i++) Number[<span class="variable">$i</span>]++ &#125;</div><div class="line">END&#123;<span class="keyword">for</span>(course <span class="keyword">in</span> Number) <span class="built_in">printf</span>(<span class="string">"%10s %d\n"</span>, course, Number[course] )&#125;</div></pre></td></tr></table></figure></p>
<p>第一个<code>Pattern { Actions }</code>指令中省略了Pattern 部分. 故随着每笔数据行的读入其<code>Actions</code>部分将逐次无条件被执行.<br>以awk读入第一笔资料”Mary O.S. Arch. Discrete”为例, 因为该笔数据<code>NF = 4</code>(有4个字段), 故该 Action 的<code>for Loop</code>中<code>i = 2,3,4</code>.<br><code>i $i</code> 最初 <code>Number[$i] Number[$i]++</code> 之后<br><code>i=2</code>时 <code>$i=&quot;O.S.&quot; Number[&quot;O.S.&quot;]</code> 的值从默认的0,变成了1;<br><code>i=3</code>时 <code>$i=&quot;Arch.&quot; Number[&quot;Arch.&quot;]</code> 的值从默认的0,变成了1;<br>同理,<code>i=4</code>时 <code>$i=&quot;Discrete&quot; Number[&quot;Discrete&quot;]</code> 的值从默认的0,变成了1;</p>
<p>第二个<code>Pattern { Actions }</code>指令中 <code>END</code> 为awk之保留字, 为 Pattern 的一种.<br><code>END</code> 成立(其值为true)的条件是: “awk处理完所有数据, 即将离开程序时.”<br>平常读入数据行时,<code>END</code>并不成立, 故其后的Actions并不被执行;<br>唯有当awk读完所有数据时, 该Actions才会被执行(注意, 不管数据行有多少笔,<code>END</code>仅在最后才成立, 故该Actions仅被执行一次.)</p>
<p><code>BEGIN</code> 与 <code>END</code> 有点类似, 是awk中另一个保留的Pattern.<br>唯一不同的是: “以<code>BEGIN</code>为<code>Pattern</code>的<code>Actions</code>于程序一开始执行时, 被执行一次.”</p>
<p><code>NF</code>为awk的内建变量, 用以表示awk正处理的数据行中, 所包含的字段个数.</p>
<p>awk程序中若含有以<code>$</code>开头的自定变量, 都将以如下方式解释:<br>以<code>i= 2</code>为例, <code>$i = $2</code> 表第二个字段数据. (实际上,<code>$</code> 在 awk 中为一运算符(Operator), 用以取得字段数据.)</p>
<h2 id="awk-程序中使用-Shell-命令"><a href="#awk-程序中使用-Shell-命令" class="headerlink" title="awk 程序中使用 Shell 命令"></a>awk 程序中使用 Shell 命令</h2><p>awk程序中允许呼叫Shell指令. 并提供管道解决awk与系统间数据传递的问题. 所以awk很容易使用系统资源. 读者可利用这个特点来编写某些适用的系统工具.</p>
<p>范例: 写一个awk程序来打印出线上人数.<br>将下列程序建文件, 命名为 <code>count.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">    <span class="keyword">while</span> ( <span class="string">"who"</span> | getline ) n++</div><div class="line">    <span class="built_in">print</span> n</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并执行下列命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="_">-f</span> count.awk</div></pre></td></tr></table></figure></p>
<p>执行结果将会印出目前在线人数</p>
<p>说明:<br>awk 程序并不一定要处理数据文件. 以本例而言, 仅输入程序文件<code>count.awk</code>, 未输入任何数据文件.</p>
<p><code>BEGIN</code> 和 <code>END</code> 同为awk中的一种 Pattern. 以 <code>BEGIN</code>为 Pattern 的 Actions, 只有在awk开始执行程序,尚未开启任何输入文件前, 被执行一次.(注意: 只被执行一次)</p>
<p><code>|</code> 为 awk 中表示管道的符号. awk 把<code>|</code>之前的字符串<code>&quot;who&quot;</code>当成Shell上的命令, 并将该命令送往Shell执行, 执行的结果(原先应于屏幕印出者)则藉由pipe送进awk程序中.</p>
<p><code>getline</code>为awk所提供的输入指令. 其语法如下:</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>由何处读取数据</th>
<th>数据读入后置于</th>
</tr>
</thead>
<tbody>
<tr>
<td>getline var <code>&lt;</code> file</td>
<td>所指定的file</td>
<td>变量 <code>var</code>(<code>var</code>省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td><code>pipe</code> 变量</td>
<td>变量 <code>var</code>(<code>var</code>省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td>见 注一</td>
<td>变量 var(<code>var</code>省略时,表示置于<code>$0</code>)</td>
</tr>
</tbody>
</table>
<p>注一: 当 Pattern 为 <code>BEGIN</code> 或 <code>END</code>时, <code>getline</code> 将从<code>stdin</code> 读取数据, 否则从awk正处理的数据文件上读取数据.</p>
<p><code>getline</code> 一次读取一行数据, 若读取成功则<code>return 1</code>, 若读取失败则<code>return -1</code>, 若遇到文件结束(<code>EOF</code>), 则<code>return 0</code>;</p>
<p>本程序使用 <code>getline</code> 所 <code>return</code> 的数据来做为 <code>while</code> 判断循环停止的条件, 某些awk版本较旧,并不容许使用者改变 <code>$0</code> 之值. 这种版的 awk 执行本程序时会产生<code>Error</code>, 读者可于 <code>getline</code> 之后置上一个变量 (如此, <code>getline</code> 读进来的数据便不会被置于 <code>$0</code> ), 或直接改用gawk便可解决.</p>
<h2 id="awk-程序的应用实例"><a href="#awk-程序的应用实例" class="headerlink" title="awk 程序的应用实例"></a>awk 程序的应用实例</h2><p>本节将示范一个统计上班到达时间及迟到次数的程序.</p>
<p>这程序每日被执行时将读入二个文件:</p>
<ol>
<li>员工当日到班时间的数据文件 (如下列之<code>arr.dat</code>)</li>
<li>存放员工当月迟到累计次数的文件.</li>
</ol>
<p>当程序执行执完毕后将更新第二个文件的数据(迟到次数), 并打印当日的报表.这程序将分成下列数小节逐步完成, 其大纲如下:</p>
<p>[1] 在到班资料文件 arr.dat 之前增加一行抬头<br>“<code>ID Number Arrvial Time</code>“, 并产生报表输出到文件<code>today_rpt1</code>中.</p>
<p><strong>思考: 在awk中如何将数据输出到文件</strong></p>
<p>[2] 将 <code>today_rpt1</code> 上的数据按员工代号排序, 并加注执行当日日期; 产生文件 <code>today_rpt2</code></p>
<p><strong>思考 awk中如何运用系统资源及awk中Pipe之特性</strong></p>
<p>[3] 将awk程序包含在一个shell script文件中</p>
<p>[4] 于 <code>today_rpt2</code> 每日报表上, 迟到者之前加上”*”, 并加注当日平均到班时间;产生文件 <code>today_rpt3</code></p>
<p>[5] 从文件中读取当月迟到次数, 并根据当日出勤状况更新迟到累计数.</p>
<p><strong>思考 使用者在awk中如何读取文件数据</strong></p>
<p>某公司其员工到勤时间档如下, 取名为 <code>arr.dat</code>. 文件中第一栏为员工代号, 第二栏为到达时间. 本范例中, 将使用该文件为数据文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1034 7:26</div><div class="line">1025 7:27</div><div class="line">1101 7:32</div><div class="line">1006 7:45</div><div class="line">1012 7:46</div><div class="line">1028 7:49</div><div class="line">1051 7:51</div><div class="line">1029 7:57</div><div class="line">1042 7:59</div><div class="line">1008 8:01</div><div class="line">1052 8:05</div><div class="line">1005 8:12</div></pre></td></tr></table></figure></p>
<h3 id="重定向输出到文件"><a href="#重定向输出到文件" class="headerlink" title="重定向输出到文件"></a>重定向输出到文件</h3><p>awk中并未提供如 C 语言中之 <code>fopen()</code> 指令, 也未有 <code>fprintf()</code> 文件输出这样的指令. 但awk中任何输出函数之后皆可借助使用与UNIX中类似的 I/O 重定向符, 将输出的数据重定向到指定的文件; 其符号仍为 <code>&gt;</code> (输出到一个新产生的文件) 或 <code>&gt;&gt;</code> (添加输出的数据到文件末尾).</p>
<p>[例:] 在到班数据文件 <code>arr.dat</code> 之前增加一行抬头如下:<br><code>&quot;ID Number Arrival Time&quot;</code>, 并产生报表输出到文件 <code>today_rpt1</code> 中</p>
<p>建立如下文件并取名为reformat1.awk<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; <span class="built_in">print</span> <span class="string">" ID Number Arrival Time"</span> &gt; <span class="string">"today_rpt1"</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"==========================="</span> &gt; <span class="string">"today_rpt1"</span></div><div class="line">&#125;</div><div class="line">&#123; <span class="built_in">printf</span>(<span class="string">" %s %s\n"</span>, <span class="variable">$1</span>,<span class="variable">$2</span> ) &gt; <span class="string">"today_rpt1"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> reformat1.awk arr.dat</div></pre></td></tr></table></figure></p>
<p>执行后将产生文件 today_rpt1, 其内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ID Number Arrival Time</div><div class="line">============================</div><div class="line">1034 7:26</div><div class="line">1025 7:27</div><div class="line">1101 7:32</div><div class="line">1006 7:45</div><div class="line">1012 7:46</div><div class="line">1028 7:49</div><div class="line">1051 7:51</div><div class="line">1029 7:57</div><div class="line">1042 7:59</div><div class="line">1008 8:01</div><div class="line">1052 8:05</div><div class="line">1005 8:12</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>awk程序中, 文件名称 <code>today_rpt1</code> 的前后须以<code>&quot;</code>(双引号)括住, 表示 <code>today_rpt1</code> 为一字符串常量. 若未以<code>&quot;</code>括住, 则 <code>today_rpt1</code> 将被awk解释为一个变量名称.</p>
<p>在awk中任何变量使用之前, 并不须事先声明. 其初始值为空字符串(Null string) 或 0.因此程序中若未以<code>&quot;</code>将 <code>today_rpt1</code> 括住, 则 <code>today_rpt1</code> 将是一变量, 其值将是空字符串, 这会在执行时造成错误(Unix 无法帮您开启一个以空字符串为文件名的文件).</p>
<p>因此在编辑awk程序时, 须格外留心. 因为若敲错变量名称, awk在编译程序时会认为是一新的变量, 并不会察觉. 因此往往会造成运行时错误.</p>
<p><code>BEGIN</code> 为awk的保留字, 是 Pattern 的一种.<br>以 <code>BEGIN</code> 为 Pattern 的 Actions 于awk程序刚被执行尚未读取数据文件时被执行一次, 此后便不再被执行.</p>
<p>读者或许觉得本程序中的I/O重定向符号应使用”<code>&gt;&gt;</code>“(append)而非”<code>&gt;</code>“.</p>
<p>本程序中若使用”<code>&gt;</code>“ 将数据重导到<code>today_rpt1</code>, awk 第一次执行该指令时会产生一个新档<code>today_rpt1</code>, 其后再执行该指令时则把数据追加到<code>today_rpt1</code>文件末, 并非每执行一次就重开一个新文件.</p>
<p>若采用”<code>&gt;&gt;</code>“其差异仅在第一次执行该指令时, 若已存在<code>today_rpt1</code>则 awk 将直接把数据append在原文件之末尾. 这一点, 与UNIX中的用法不同.</p>
<h3 id="awk-中如何利用系统资源"><a href="#awk-中如何利用系统资源" class="headerlink" title="awk 中如何利用系统资源"></a>awk 中如何利用系统资源</h3><p>awk程序中很容易使用系统资源. 这包括在程序中途调用 Shell 命令来处理程序中的部分数据; 或在调用 Shell 命令后将其产生的结果交回 awk 程序(不需将结果暂存于某个文件). 这一过程是借助 awk 所提供的管道 (虽然有些类似 Unix 中的管道, 但特性有些不同),及一个从 awk 中呼叫 Unix 的 Shell 命令的语法来达成的.</p>
<p>[例:] 承上题, 将数据按员工ID排序后再输出到文件 today_rpt2 , 并于表头附加执行时的日期.</p>
<p>[分析:]<br>awk 提供与 UNIX 用法近似的 pipe, 其记号亦为”<code>|</code>“. 其用法及含意如下:<br>awk程序中可接受下列两种语法:<br>[a.语法] awk output 指令 | “Shell 接受的命令”<br>(如: <code>print $1,$2 | &quot;sort -k 1&quot;</code>)<br>[b.语法] “Shell 接受的命令” | awk input 指令<br>(如: <code>&quot;ls&quot; | getline</code>)<br>注: awk input 指令只有 <code>getline</code> 一个.<br>awk output 指令有<code>print</code>, <code>printf()</code> 二个.</p>
<p>在 a 语法中, awk所输出的数据将转送往 Shell , 由 Shell 的命令进行处理.以上例而言, <code>print</code> 所输出的数据将经由 Shell 命令<code>&quot;sort -k 1&quot;</code>排序后再送往屏幕(stdout).</p>
<p>上列awk程序中, “<code>print$1, $2</code>“ 可能反复执行很多次, 其输出的结果将先暂存于 pipe 中,等到该程序结束时, 才会一并进行<code>&quot;sort -k 1&quot;</code>.</p>
<p>须注意二点: 不论<code>print $1, $2</code>被执行几次,<code>&quot;sort -k 1&quot;</code>的执行时间是”awk程序结束时”,<code>&quot;sort -k 1&quot;</code>的执行次数是”一次”.</p>
<p>在 b 语法中, awk将先调用 Shell 命令. 其执行结果将通过 pipe 送入awk程序,以上例而言, awk 先让 Shell 执行 <code>&quot;ls&quot;</code>, Shell 执行后将结果存于 pipe, awk指令<code>getline</code>再从 pipe 中读取数据.</p>
<p>使用本语法时应留心: 以上例而言,awk “立刻”调用 Shell 来执行<code>&quot;ls&quot;</code>, 执行次数是一次.</p>
<p><code>getline</code> 则可能执行多次 (若pipe中存在多行数据).</p>
<p>除上列 a, b 二中语法外, awk程序中其它地方如出现像<code>&quot;date&quot;</code>, <code>&quot;cls&quot;</code>, <code>&quot;ls&quot;</code>… 这样的字符串, awk只把它当成一般字符串处理.</p>
<p>建立如下文件并取名为 <code>reformat2.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 程序 reformat2.awk</span></div><div class="line"><span class="comment"># 这程序用以练习awk中的pipe</span></div><div class="line">BEGIN &#123;</div><div class="line">    <span class="string">"date"</span> | getline <span class="comment"># Shell 执行 "date". getline 取得结果并以$0记录</span></div><div class="line">    <span class="built_in">print</span> <span class="string">" Today is "</span> , <span class="variable">$2</span>, <span class="variable">$3</span> &gt; <span class="string">"today_rpt2"</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"========================="</span> &gt; <span class="string">"today_rpt2"</span></div><div class="line">    <span class="built_in">print</span> <span class="string">" ID Number Arrival Time"</span> &gt; <span class="string">"today_rpt2"</span></div><div class="line">    close( <span class="string">"today_rpt2"</span> )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;<span class="built_in">printf</span>( <span class="string">"%s %s\n"</span>, <span class="variable">$1</span> ,<span class="variable">$2</span> ) | <span class="string">"sort -k 1 &gt;&gt;today_rpt2"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>执行如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="_">-f</span> reformat2.awk arr.dat</div></pre></td></tr></table></figure></p>
<p>执行后, 系统会自动将 sort 后的数据追加(Append; 因为使用 “<code>&gt;&gt;</code>“) 到文件<code>today_rpt2</code>末端. <code>today_rpt2</code> 内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Today is  09月 21日</div><div class="line">=========================</div><div class="line"> ID Number Arrival Time</div><div class="line">1005 8:12</div><div class="line">1006 7:45</div><div class="line">1008 8:01</div><div class="line">1012 7:46</div><div class="line">1025 7:27</div><div class="line">1028 7:49</div><div class="line">1029 7:57</div><div class="line">1034 7:26</div><div class="line">1042 7:59</div><div class="line">1051 7:51</div><div class="line">1052 8:05</div><div class="line">1101 7:32</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>awk程序由三个主要部分构成:<br>[i.] <code>Pattern { Action}</code>指令<br>[ii.] 函数主体. 例如:<code>function double( x ){ return 2*x }</code> (参考第11节 Recursive Program )<br>[iii.] Comment (以<code>#</code>开头识别之)</p>
<p>awk 的输入指令<code>getline</code>, 每次读取一列数据. 若<code>getline</code>之后未接任何变量, 则所读入之资料将以<code>$0</code>记录, 否则以所指定的变量储存之.</p>
<p>[以本例而言]:<br>执行 <code>&quot;date&quot; | getline</code> 后, <code>$0</code> 之值为 “2007年 09月 21日 星期五 14:28:02 CST”,当 <code>$0</code> 之值被更新时, awk将自动更新相关的内建变量, 如: <code>$1</code>,<code>$2</code>,..,<code>NF</code>.故 <code>$2</code> 之值将为”09月”, <code>$3</code>之值将为”21日”.</p>
<p>(有少数旧版的awk不允许即使用者自行更新(update)<code>$0</code>的值,或者更新<code>$0</code>时,它不会自动更新 <code>$1</code>,<code>$2</code>,..<code>NF</code>. 这情况下, 可改用<code>gawk</code>或<code>nawk</code>. 否则使用者也可自行以awk字符串函数<code>split()</code>来分隔<code>$0</code>上的数据)</p>
<p>本程序中 <code>printf()</code> 指令会被执行12次( 因为有<code>arr.dat</code>中有12行数据), 但读者不用担心数据被重复<code>sort</code>了12次. 当awk结束该程序时才会 <code>close</code> 这个 pipe , 此时才将这12行数据一次送往系统,并呼叫<code>&quot;sort -k 1 &gt;&gt; today_rpt2&quot;</code>处理之.</p>
<p>awk提供另一个调用Shell命令的方法, 即使用awk函数<code>system(&quot;shell command&quot;)</code><br>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;</div><div class="line">BEGIN&#123;</div><div class="line">system(&quot;date &gt; date.dat&quot;)</div><div class="line">getline &lt; &quot;date.dat&quot;</div><div class="line">print &quot;Today is &quot;, $2, $3</div><div class="line">&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>但使用<code>system(&quot;shell command&quot;)</code>时, awk无法直接将执行中的部分数据输出给Shell 命令. 且 Shell 命令执行的结果也无法直接输入到awk中.</p>
<h3 id="执行-awk-程序的几种方式"><a href="#执行-awk-程序的几种方式" class="headerlink" title="执行 awk 程序的几种方式"></a>执行 awk 程序的几种方式</h3><p>本小节中描述如何将awk程序直接写在 shell script 之中. 此后使用者执行 awk 程序时, 就不需要每次都键入”<code>awk -f program datafile</code>“.</p>
<p>script 中还可包含其它 Shell 命令, 如此更可增加执行过程的自动化.</p>
<p>建立一个简单的 awk程序 mydump.awk, 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">print</span> &#125;</div></pre></td></tr></table></figure></p>
<p>这个程序执行时会把数据文件的内容 <code>print</code> 到屏幕上( 与cat功用类似 ).</p>
<p><code>print</code> 之后未接任何参数时, 表示 “<code>print $0</code>“.</p>
<p>若欲执行该awk程序, 来印出文件 <code>today_rpt1</code> 及 <code>today_rpt2</code> 的内容时, 必须于 UNIX 的命令行上执行下列命令:<br>方式一 <code>awk -f mydump.awk today_rpt1 today_rpt2</code><br>方式二 <code>awk &#39;{ print }&#39; today_rpt1 today_rpt2</code><br>第二种方式系将awk 程序直接写在 Shell 的命令行上, 这种方式仅适合较短的awk程序.<br>方式三 建立如下之 shell script, 并取名为<code>mydisplay</code>,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line"><span class="comment"># 注意以下的 awk 与 ' 之间须有空白隔开</span></div><div class="line">awk <span class="string">'</span></div><div class="line">&#123;print&#125;</div><div class="line">' $*</div><div class="line"><span class="comment"># 注意以上的 ' 与 $* 之间须有空白隔开</span></div></pre></td></tr></table></figure></p>
<p>执行 <code>mydisplay</code> 之前, 须先将它改成可执行的文件(此步骤往后不再赘述). 请执行如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x mydisplay</div></pre></td></tr></table></figure></p>
<p>往后使用者就可直接把 <code>mydisplay</code> 当成指令, 来display任何文件.<br>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./mydisplay today_rpt1 today_rpt2</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>在script文件 <code>mydisplay</code> 中, 指令”<code>awk</code>“与第一个<code>&#39;</code> 之间须有空格(Shell中并无” <code>awk&#39;</code> “指令).<br>第一个 <code>&#39;</code> 用以通知 Shell 其后为awk程序.<br>第二个<code>&#39;</code> 则表示 awk 程序结束.<br>故awk程序中一律以<code>&quot;</code>括住字符串或字符, 而不使用<code>&#39;</code>, 以免Shell混淆.<br><code>$*</code> 为 shell script中的用法, 它可用来代表命令行上”<code>mydisplay</code>之后的所有参数”.<br>例如执行 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mydisplay today_rpt1 today_rpt2</div></pre></td></tr></table></figure></p>
<p>事实上 Shell 已先把该指令转换成:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123; print&#125;</div><div class="line">' today_rpt1 today_rpt2</div></pre></td></tr></table></figure></p>
<p>本例中, <code>$*</code> 用以代表 <code>&quot;today_rpt1 today_rpt2&quot;</code>. 在Shell的语法中, 可用<code>$1</code> 代表第一个参数, <code>$2</code>代表第二个参数. 当不确定命令行上的参数个数时, 可使用 <code>$*</code> 表之.</p>
<p>awk命令行上可同时指定多个数据文件.<br>以<code>awk -f dump.awk today_rpt1 today_rpt2hf</code>为例, awk会先处理<code>today_rpt1</code>, 再处理 <code>today_rpt2</code>. 此时若文件无法打开, 将造成错误.<br>例如: 不存在文件”<code>file_no_exist</code>“, 则执行 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> dump.awk file_no_exit</div></pre></td></tr></table></figure></p>
<p>将产生运行时错误(无法打开文件).</p>
<p>但某些awk程序 “仅” 包含以 <code>BEGIN</code> 为Pattern的指令. 执行这种awk程序时, awk并不须开启任何数据文件.此时命令行上若指定一个不存在的数据文件,并不会产生 “无法打开文件”的错误.(事实上awk并未打开该文件)<br>例如执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'BEGIN &#123;print "Hello,World!!"&#125; '</span> file_no_exist</div></pre></td></tr></table></figure></p>
<p>该程序中仅包含以 <code>BEGIN</code> 为 Pattern 的 <code>Pattern {actions}</code>, awk 执行时并不会开启任何数据文件; 所以不会因不存在文件<code>file_no_exit</code>而产生 “无法打开文件”的错误.</p>
<p>awk会将 Shell 命令行上awk程序(或 -f 程序文件名)之后的所有字符串, 视为将输入awk进行处理的数据文件文件名.</p>
<p>若执行awk的命令行上 “未指定任何数据文件文件名”, 则将<code>stdin</code>视为输入之数据来源, 直到输入<code>end of file( Ctrl-D )</code>为止.</p>
<p>读者可以用下列程序自行测试, 执行如下命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> mydump.awk  <span class="comment">#(未接任何数据文件文件名)</span></div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./mydisplay  <span class="comment">#(未接任何数据文件文件名)</span></div></pre></td></tr></table></figure></p>
<p>将会发现: 此后键入的任何数据将逐行复印一份于屏幕上. 这情况不是机器当机 ! 是因为awk程序正处于执行中. 它正按程序指示, 将读取数据并重新dump一次; 只因执行时未指定数据文件文件名, 故awk 便以stdin(键盘上的输入)为数据来源. 读者可利用这个特点, 设计可与awk即时聊天的程序.</p>
<h3 id="改变-awk-切割字段的方式-amp-自定义函数"><a href="#改变-awk-切割字段的方式-amp-自定义函数" class="headerlink" title="改变 awk 切割字段的方式 &amp; 自定义函数"></a>改变 awk 切割字段的方式 &amp; 自定义函数</h3><p>awk不仅能自动分割字段, 也允许使用者改变其字段切割方式以适应各种格式之需要. 使用者也可自定义函数, 若有需要可将该函数单独写成一个文件,以供其它awk程序调用.</p>
<p>[范例:] 承接 6.2 的例子, 若八点为上班时间, 请加注”<code>*</code>“于迟到记录之前, 并计算平均上班时间.<br>[分析:]<br>因八点整到达者,不为迟到, 故仅以到达的小时数做判断是不够的; 仍应参考到达时的分钟数. 若 “将到达时间转换成以分钟为单位”, 不仅易于判断是否迟到, 同时也易于计算到达平均时间.<br>到达时间(<code>$2</code>)的格式为<code>dd:dd</code>或<code>d:dd</code>; 数字当中含有一个”<code>:</code>“. 但文本数字交杂的数据awk无法直接做数学运算. (注: awk中字符串”<code>26</code>“与数字<code>26</code>, 并无差异, 可直接做字符串或数学运算, 这是awk重要特色之一. 但awk对文本数字交杂的字符串无法正确进行数学运算).</p>
<p>解决之方法:<br>[方法一]<br>对到达时间(<code>$2</code>)<code>d:dd</code>或<code>dd:dd</code>进行字符串运算,分别取出到达的小时数及分钟数.<br>首先判断到达小时数为一位或两位字符,再调用函数分别截取分钟数及小时数.<br>此解法需使用下列awk字符串函数:<br><code>length( 字符串 )</code>:返回该字符串的长度.<br><code>substr( 字符串,起始位置,长度)</code>:返回从起始位置起, 指定长度之子字符串. 若未指定长度, 则返回从起始位置到字符串末尾的子字符串.<br>所以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">小时数 = substr( $2, 1, length($2) - 3 )</div><div class="line">分钟数 = substr( $2, length($2) - 2 )</div></pre></td></tr></table></figure></p>
<p>[方法二]<br>改变输入列字段的切割方式, 使awk切割字段后分别将小时数及分钟数隔开于二个不同的字段.<br>字段分隔字符<code>FS</code> (field seperator) 是awk的内建变量,其默认值是<code>空白</code>及<code>tab</code>. awk每次切割字段时都会先参考<code>FS</code>的内容. 若把”<code>:</code>“也当成分隔字符, 则awk 便能自动把小时数及分钟数分隔成不同的字段.故令<code>FS = &quot;[ \t:]+&quot;</code> (注: <code>[ \t:]+</code> 为一Regular Expression )<br>Regular Expression 中使用中括号<code>[ ... ]</code>表示一个字符集合,用以表示任意一个位于两中括号间的字符.故可用”<code>[ \t:]</code>“表示 一个<code>空白</code>, <code>tab</code> 或 “<code>:</code>“。<br>Regular Expression中使用”<code>+</code>“形容其前方的字符可出现一次或一次以上.<br>故”<code>[ \t:]+</code>“表示由一个或多个 <code>空白</code>, <code>tab</code> 或 <code>:</code> 所组成的字符串.<br>设定<code>FS =&quot;[ \t:]+&quot;</code>后, 数据行如:<code>&quot;1034 7:26&quot;</code>将被分割成3个字段</p>
<p>第一栏 第二栏 第三栏<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span></div><div class="line">1034 7 26</div></pre></td></tr></table></figure></p>
<p>明显地, awk程序中使用方法二比方法一更简洁方便. 本例子中采用方法二,也借此示范改变字段切割方式的用途.</p>
<p>编写awk程序<code>reformat3</code>, 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    FS= "[ \t:]+" #改变字段切割的方式</div><div class="line">    "date" | getline # Shell 执行 "date". getline 取得结果以$0记录</div><div class="line">    print " Today is " ,$2, $3 &gt; "today_rpt3"</div><div class="line">    print "========================="&gt;"today_rpt3"</div><div class="line">    print " ID Number Arrival Time" &gt; "today_rpt3"</div><div class="line">    close( "today_rpt3" )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    #已更改字段切割方式, $2表到达小时数, $3表分钟数</div><div class="line">    arrival = HM_to_M($2, $3)</div><div class="line">    printf(" %s %s:%s %s\n", $1, $2, $3, arrival &gt; 480 ? "*": " " ) | "sort -k 1 &gt;&gt; today_rpt3"</div><div class="line">    total += arrival</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">    close("today_rpt3")</div><div class="line">    close("sort -k 1 &gt;&gt; today_rpt3")</div><div class="line">    printf(" Average arrival time : %d:%d\n",total/NR/60, (total/NR)%60 ) &gt;&gt; "today_rpt3"</div><div class="line">&#125;</div><div class="line"></div><div class="line">function HM_to_M( hour, min )&#123;</div><div class="line">    return hour*60 + min</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>并执行如下指令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./reformat3 arr.dat</div></pre></td></tr></table></figure></p>
<p>执行后,文件 today_rpt3 的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> Today is  09月 21日</div><div class="line">=========================</div><div class="line"> ID Number Arrival Time</div><div class="line"> 1005 8:12 *</div><div class="line"> 1006 7:45</div><div class="line"> 1008 8:01 *</div><div class="line"> 1012 7:46</div><div class="line"> 1025 7:27</div><div class="line"> 1028 7:49</div><div class="line"> 1029 7:57</div><div class="line"> 1034 7:26</div><div class="line"> 1042 7:59</div><div class="line"> 1051 7:51</div><div class="line"> 1052 8:05 *</div><div class="line"> 1101 7:32</div><div class="line"> Average arrival time : 7:49</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>awk 中亦允许使用者自定函数. 函数定义方式请参考本程序, <code>function</code> 为 awk 的保留字.<br><code>HM_to_M()</code>这函数负责将所传入之小时及分钟数转换成以分钟为单位. 使用者自定函数时, 还有许多细节须留心, 如data scope,.. ( 请参考 第十节 Recursive Program)<br>awk中亦提供与 C 语言中相同的 Conditional Operator. 上式<code>printf()</code>中使用<code>arrival &gt;480 ? &quot;*&quot; : &quot; &quot;</code>即为一例若 <code>arrival</code> 大于 <code>480</code> 则<code>return &quot;*&quot;</code>, 否则<code>return &quot; &quot;</code>.<br><code>%</code>为awk的运算符(operator), 其作用与 C 语言中之<code>%</code>相同(取余数).<br><code>NR</code>(Number of Record) 为awk的内建变量. 表示awk执行该程序后所读入的记录笔数.</p>
<p>awk 中提供的<code>close()</code>指令, 语法如下(有二种) :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close( filename )</div><div class="line">close( 置于pipe之前的<span class="built_in">command</span> )</div></pre></td></tr></table></figure></p>
<p>为何本程序使用了两个<code>close()</code>指令:<br>指令 <code>close(&quot;sort -k 1 &gt;&gt; today_rpt3&quot;)</code>, 其意思为 close 程序中置于<code>&quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code>之前的 Pipe, 并立刻调用 Shell 来执行<code>&quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code>. (若未执行这指令, awk必须于结束该程序时才会进行上述动作; 则这12笔sort后的数据将被 append 到文件 <code>today_rpt3</code> 中 “<code>Average arrival time : ...</code>“ 的后方)<br>因为 Shell 排序后的数据也要写到 <code>today_rpt3</code>, 所以awk必须先关闭使用中的<code>today_rpt3</code> 以使 Shell 正确将排序后的数据追加到<code>today_rpt3</code>否则2个不同的 process 同时打开一个文件进行输出将会产生不可预期的结果.<br>读者应留心上述两点,才可正确控制数据输出到文件中的顺序.<br>指令<code>close(&quot;sort -k 1 &gt;&gt; today_rpt3&quot;)</code>中字符串<code>&quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code> 必须与 pipe <code>|</code> 后方的 Shell Command 名称一字不差, 否则awk将视为二个不同的 pipe.<br>读者可于<code>BEGIN{}</code>中先令变量 <code>Sys_call = &quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code>,<br>程序中再一律以 <code>Sys_call</code> 代替该字符串.</p>
<h3 id="使用-getline-来读取数据"><a href="#使用-getline-来读取数据" class="headerlink" title="使用 getline 来读取数据"></a>使用 getline 来读取数据</h3><p>[范例:] 承上题,从文件中读取当月迟到次数, 并根据当日出勤状况更新迟到累计数.(按不同的月份累计于不同的文件)<br>[分析:]<br>程序中自动抓取系统日期的月份名称, 连接上”<code>late.dat</code>“, 形成累计迟到次数的文件名称(如: 09月late.dat,…), 并以变量<code>late_file</code>记录该文件名.<br>累计迟到次数的文件中的数据格式为: 员工代号(ID) 迟到次数<br>例如, 执行本程序前文件 09月late.dat 的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1012 0</div><div class="line">1006 1</div><div class="line">1052 2</div><div class="line">1034 0</div><div class="line">1005 0</div><div class="line">1029 2</div><div class="line">1042 0</div><div class="line">1051 0</div><div class="line">1008 0</div><div class="line">1101 0</div><div class="line">1025 1</div><div class="line">1028 0</div></pre></td></tr></table></figure></p>
<p>编写程序 reformat4 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    Sys_Sort = "sort -k 1 &gt;&gt; today_rpt4"</div><div class="line">    Result = "today_rpt4"</div><div class="line">    # 改变字段切割的方式</div><div class="line">    FS = "[ \t:]+"</div><div class="line">    # 令 Shell执行"date"; getline 读取结果,并以$0记录</div><div class="line">    "date" | getline</div><div class="line">    print " Today is " , $2, $3 &gt;Result</div><div class="line">    print "=========================" &gt; Result</div><div class="line">    print " ID Number Arrival Time" &gt; Result</div><div class="line">    close( Result )</div><div class="line">    # 从文件按中读取迟到数据, 并用数组cnt[ ]记录. 数组cnt[ ]中以</div><div class="line">    # 员工代号为下标, 所对应的值为该员工之迟到次数.</div><div class="line">    late_file = $2"late.dat"</div><div class="line">    while( getline &lt; late_file &gt;0 ) cnt[$1] = $2</div><div class="line">    close( late_file )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    # 已更改字段切割方式, $2表小时数,$3表分钟数</div><div class="line">    arrival = HM_to_M($2, $3)</div><div class="line">    if( arrival &gt; 480 )&#123;</div><div class="line">    mark = "*" # 若当天迟到,应再增加其迟到次数, 且令mark 为"*".</div><div class="line">    cnt[$1]++ &#125;</div><div class="line">    else mark = " "</div><div class="line"></div><div class="line">    # message 用以显示该员工的迟到累计数, 若未曾迟到message为空字符串</div><div class="line">    message = cnt[$1] ? cnt[$1] " times" : ""</div><div class="line">    printf("%s %2d:%2d %5s %s\n", $1, $2, $3, mark, message ) | Sys_Sort</div><div class="line">    total += arrival</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">    close( Result )</div><div class="line">    close( Sys_Sort )</div><div class="line">    printf(" Average arrival time : %d:%d\n", total/NR/60, (total/NR)%60 ) &gt;&gt; Result</div><div class="line">    #将数组cnt[ ]中新的迟到数据写回文件中</div><div class="line">    for( any in cnt )</div><div class="line">    print any, cnt[any] &gt; late_file</div><div class="line">&#125;</div><div class="line"></div><div class="line">function HM_to_M( hour, min )&#123;</div><div class="line">    return hour*60 + min</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行后, today_rpt4 之内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> Today is  09月 21日</div><div class="line">=========================</div><div class="line"> ID Number Arrival Time</div><div class="line">1005  8:12     * 1 times</div><div class="line">1006  7:45       1 times</div><div class="line">1008  8: 1     * 1 times</div><div class="line">1012  7:46</div><div class="line">1025  7:27       1 times</div><div class="line">1028  7:49</div><div class="line">1029  7:57       2 times</div><div class="line">1034  7:26</div><div class="line">1042  7:59</div><div class="line">1051  7:51</div><div class="line">1052  8: 5     * 3 times</div><div class="line">1101  7:32</div><div class="line"> Average arrival time : 7:49</div></pre></td></tr></table></figure></p>
<p>09月late.dat 文件被修改为如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1005 1</div><div class="line">1012 0</div><div class="line">1006 1</div><div class="line">1008 1</div><div class="line">1101 0</div><div class="line">1025 1</div><div class="line">1034 0</div><div class="line">1042 0</div><div class="line">1028 0</div><div class="line">1029 2</div><div class="line">1051 0</div><div class="line">1052 3</div></pre></td></tr></table></figure></p>
<p>说明:<br><code>late_file</code>是一变量, 用以记录迟到次数的文件的文件名.<br><code>late_file</code>之值由两部分构成, 前半部是当月月份名称(由调用”date”取得)后半部固定为”late.dat” 如: 09月late.dat.<br>指令<code>getline &lt; late_file</code>表示从<code>late_file</code>所代表的文件中读取一笔记录, 并存放于<code>$0</code>.<br>若使用者可自行把数据放入<code>$0</code>, awk会自动对这新置入 <code>$0</code> 的数据进行字段分割. 之后程序中可用<code>$1</code>, <code>$2</code>,..来表示该笔资料的第一栏,第二栏,..,<br>(注: 有少数awk版本不容许使用者自行将数据置于<code>$0</code>, 遇此情况可改用gawk或nawk)<br>执行<code>getline</code>指令时, 若成功读取记录,它会返回<code>1</code>. 若遇到文件结束, 它返回<code>0</code>; 无法打开文件则返回<code>-1</code>.<br>利用<code>while( getline &lt; filename &gt;0 ) {....}</code>可读入文件中的每一笔数据并予处理. 这是awk中用户自行读取数据文件的一个重要模式.<br>数组 <code>cnt[]</code> 以员工ID. 当下标(index), 其对应值表示其迟到的次数.<br>执行结束后, 利用<code>for(Variable in array ){...}</code>的语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( any <span class="keyword">in</span> cnt ) <span class="built_in">print</span> any, cnt[any] &gt; late_file</div></pre></td></tr></table></figure></p>
<p>将更新过的迟到数据重新写回记录迟到次数的文件. 该语法在前面曾有说明.</p>
<h2 id="处理多行的数据"><a href="#处理多行的数据" class="headerlink" title="处理多行的数据"></a>处理多行的数据</h2><p>awk 每次从数据文件中只读取一数据进行处理.<br>awk是依照其内建变量 <code>RS</code> (Record Separator) 的定义将文件中的数据分隔成一行一行的Record. <code>RS</code> 的默认值是”<code>\n</code>“ (换行符号), 故平常awk中一行数据就是一笔 Record. 但有些文件中一笔Record涵盖了多行数据, 这种情况下不能再以”<code>\n</code>“来分隔Records. 最常使用的方法是相邻的Records之间改以一个<code>空白行</code>来隔开. 在awk程序中, 令<code>RS = &quot;&quot;</code>(空字符串)后, awk把会空白行当成来文件中Record的分隔符. 显然awk对<code>RS = &quot;&quot;</code>另有解释方式,简略描述如下, 当<code>RS = &quot;&quot;</code> 时:数个并邻的空白行, awk仅视成一个单一的Record Saparator. (awk不会于两个紧并的空白行之间读取一笔空的Record)<br>awk会略过(skip)文件头或文件尾的空白行. 故不会因为这样的空白行,造成awk多读入了二笔空的数据.</p>
<p>请观察下例,首先建立一个数据文件<code>week.rpt</code>如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">张长弓</div><div class="line">GNUPLOT 入门</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">吴国强</div><div class="line">Latex 简介</div><div class="line">VAST-2 使用手册</div><div class="line">mathematic 入门</div><div class="line"></div><div class="line">李小华</div><div class="line">awk Tutorial Guide</div><div class="line">Regular Expression</div></pre></td></tr></table></figure></p>
<p>该文件的开头有数行空白行, 各笔Record之间使用一个或数个空白行隔开. 读者请细心观察,当<code>RS = &quot;&quot;</code> 时, awk读取该数据文件之方式.</p>
<p>编辑一个awk程序文件 make_report如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    FS = "\n"</div><div class="line">    RS = ""</div><div class="line">    split( "一. 二. 三. 四. 五. 六. 七. 八. 九.", C_Number, " " )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    printf("\n%s 报告人 : %s \n",C_Number[NR],$1)</div><div class="line">    for( i=2; i &lt;= NF; i++) printf(" %d. %s\n", i-1, $i)</div><div class="line">&#125; ' $*</div></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make_report week.rpt</div></pre></td></tr></table></figure></p>
<p>屏幕产生结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">一. 报告人 : 张长弓</div><div class="line"> 1. GNUPLOT 入门</div><div class="line"></div><div class="line">二. 报告人 : 吴国强</div><div class="line"> 1. Latex 简介</div><div class="line"> 2. VAST-2 使用手册</div><div class="line"> 3. mathematic 入门</div><div class="line"></div><div class="line">三. 报告人 : 李小华</div><div class="line"> 1. awk Tutorial Guide</div><div class="line"> 2. Regular Expression</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>本程序同时也改变字段分隔字符(<code>FS = &quot;\n&quot;</code>), 如此一笔数据中的每一行都是一个<code>field</code>. 例如: awk读入的第一笔 Record 为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">张长弓</div><div class="line">GNUPLOT 入门</div></pre></td></tr></table></figure></p>
<p>其中<code>$1</code>指的是”<code>张长弓</code>“, <code>$2</code>指的是”<code>GNUPLOT 入门</code>“<br>上式中的<code>C_Number[]</code>是一个数组(array), 用以记录中文数字. 例如: <code>C_Number[1] = &quot;一.&quot;</code>,<code>C_Number[2] = &quot;二.&quot;</code>这过程使用awk字符串函数 <code>split()</code> 来把中文数字放进数组<code>C_Number[]</code>中.<br>函数<code>split( )</code>用法如下:<br><code>split( 原字符串, 数组名, 分隔字符(field separator) )</code> : awk将依所指定的分隔字符(field separator)分隔原字符串成一个个的字段(field), 并以指定的数组记录各个被分隔的字段</p>
<h2 id="如何读取命令行上的参数"><a href="#如何读取命令行上的参数" class="headerlink" title="如何读取命令行上的参数"></a>如何读取命令行上的参数</h2><p>大部分的应用程序都允许使用者在命令之后增加一些选择性的参数.执行awk时这些参数大部分用于指定数据文件文件名, 有时希望在程序中能从命令行上得到一些其它用途的数据. 本小节中将叙述如何在awk程序中取用这些参数.</p>
<p>建立文件如下, 命名为<code>see_arg</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    for( i=0; i&lt;ARGC ; i++)</div><div class="line">        print ARGV[i] # 依次印出awk所记录的参数</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行如下命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./see_arg first-arg second-arg</div></pre></td></tr></table></figure></p>
<p>结果屏幕出现 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">awk</div><div class="line">first-arg</div><div class="line">second-arg</div></pre></td></tr></table></figure></p>
<p>[说明:]<br><code>ARGC</code>,<code>ARGV[]</code> 为awk所提供的内建变量.<br><code>ARGC</code>: 为一整数. 代表命令行上, 除了选项<code>-v</code>,<code>-f</code> 及其对应的参数之外所有参数的数目.<br><code>ARGV[]</code>: 为一字符串数组.<code>ARGV[0]</code>,<code>ARGV[1]</code>,…<code>ARGV[ARGC-1]</code>.<br>分别代表命令行上相对应的参数.<br>例如, 当命令行为 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -vx=36 <span class="_">-f</span> program1 data1 data2</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'&#123; print $1 ,$2 &#125;'</span> data1 data2</div></pre></td></tr></table></figure></p>
<p>其<code>ARGC</code> 之值为 3<br><code>ARGV[0]</code> 之值为 “awk”<br><code>ARGV[1]</code>之值为 “data1”<br><code>ARGV[2]</code> 之值为 “data2”  </p>
<p>命令行上的”<code>-f program1</code>“, “<code>-vx=36</code>“, 或程序部分<code>&#39;{ print $1, $2}&#39;</code>都不会列入 <code>ARGC</code> 及 <code>ARGV[]</code>中.<br>awk 利用<code>ARGC</code> 来判断应开启的数据文件个数.<br>但使用者可强行改变<code>ARGC</code>; 当 <code>ARGC</code> 之值被使用者设为 <code>1</code> 时; awk将被蒙骗,误以为命令行上并无数据文件文件名, 故不会以 <code>ARGV[1]</code>,<code>ARGV[2]</code>,..为文件名来打开文件读取数据; 但在程序中仍可通过<code>ARGV[1]</code>,<code>ARGV[2]</code>,..来取得命令行上的数据.</p>
<p>某一程序 test1.awk 如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN&#123;</div><div class="line">    number = ARGC <span class="comment">#先用number 记住实际的参数个数.</span></div><div class="line">    ARGC = 2 <span class="comment"># 自行更改 ARGC=2, awk将以为只有一个资料文件</span></div><div class="line">    <span class="comment"># 仍可藉由ARGV[ ]取得命令行上的资料.</span></div><div class="line">    <span class="keyword">for</span>( i=2; i&lt;number; i++) data[i] = ARGV[i]</div><div class="line">&#125;</div><div class="line">........</div></pre></td></tr></table></figure></p>
<p>于命令行上键入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -f test1.awk data_file apple orange</div></pre></td></tr></table></figure></p>
<p>执行时 awk 会打开数据文件 <code>data_file</code> 以进行处理. 但不会打开以<code>apple</code>,<code>orange</code>为档名的文件(因为<code>ARGC</code>被改成<code>2</code>). 但仍可通过<code>ARGV[2]</code>,<code>ARGV[3]</code>取得命令行上的参数 <code>apple</code>,<code>orange</code></p>
<p>也可以用下列命令来达成上例的效果.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> <span class="built_in">test</span>2.awk -v data[2]=<span class="string">"apple"</span> -v data[3]=<span class="string">"orange"</span> data_file</div></pre></td></tr></table></figure></p>
<h2 id="编写可与用户交互的-awk-程序"><a href="#编写可与用户交互的-awk-程序" class="headerlink" title="编写可与用户交互的 awk 程序"></a>编写可与用户交互的 awk 程序</h2><p>执行awk程序时, awk会自动从文件中读取数据来进行处理, 直到文件结束.只要将awk读取数据的来源改成键盘输入,便可设计与awk 交互的程序了.</p>
<p>本节将提供一个该类程序的范例.<br>[范例:] 本节将编写一个英语生字测验的程序, 它将印出中文字意,再由使用者回答其英语生字.</p>
<p>首先编辑一个数据挡 test.dat (内容不限,格式如下)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apple 苹果</div><div class="line">orange 柳橙</div><div class="line">banana 香蕉</div><div class="line">pear 梨子</div><div class="line">starfruit 杨桃</div><div class="line">bellfruit 莲雾</div><div class="line">kiwi 奇异果</div><div class="line">pineapple 菠萝</div><div class="line">watermelon 西瓜</div></pre></td></tr></table></figure></p>
<p>编辑awk程序”c2e”如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    while( getline &lt; ARGV[1] ) &#123; #由指定的文件中读取测验数据</div><div class="line">        English[++n] = $1 # 最后, n 将表示题目之题数</div><div class="line">        Chinese[n] = $2</div><div class="line">    &#125;</div><div class="line">    ARGV[1] = "-" # "-"表示由stdin(键盘输入)</div><div class="line">    srand() # 以系统时间为随机数启始的种子</div><div class="line">    question() #产生考题</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;# awk自动读入由键盘上输入的数据(使用者回答的答案)</div><div class="line">    if($1 != English[ind] )</div><div class="line">        print "Try again!"</div><div class="line">    else&#123;</div><div class="line">        print "\nYou are right !! Press Enter to Continue --- "</div><div class="line">        getline</div><div class="line">        question()#产生考题</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function question()&#123;</div><div class="line">    ind = int(rand()* n) + 1 #以随机数选取考题</div><div class="line">    system("clear")</div><div class="line">    print " Press \"ctrl-d\" to exit"</div><div class="line">    printf("\n%s ", Chinese[ind] " 的英文生字是: ")</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行时键入如下指令 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$./c2e test.dat</div></pre></td></tr></table></figure></p>
<p>屏幕将产生如下的画面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Press &quot;ctrl-d &quot; to exit</div><div class="line">莲雾 的英文生字是:</div></pre></td></tr></table></figure></p>
<p>若输入 <code>bellfruit</code><br>程序将产生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">You are right !! Press Enter to Continue ---</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>参数 <code>test.dat</code> (<code>ARGV[1]</code>) 表示储存考题的数据文件文件名. awk 由该文件上取得考题资料后, 将 <code>ARGV[1]</code> 改成”<code>-</code>“.<br>“<code>-</code>“表示由<code>stdin</code>(键盘输入) 数据. 键盘输入数据的结束符号<code>(End of file)</code>是<code>ctrl-d</code>. 当 awk 读到 <code>ctrl-d</code> 时就停止由<code>stdin</code>读取数据.</p>
<p>awk的数学函数中提供两个与随机数有关的函数.<br><code>srand()</code>: 以当前的系统时间作为随机数的种子<br><code>rand()</code>: 返回介于 0与1之间的(近似)随机数值.</p>
<h2 id="使用-awk-编写递归程序"><a href="#使用-awk-编写递归程序" class="headerlink" title="使用 awk 编写递归程序"></a>使用 awk 编写递归程序</h2><p>awk 中除了函数的参数列(Argument List)上的参数(Arguments)外,所有变量不管于何处出现,全被视为全局变量. 其生命持续至程序结束 — 该变量不论在function外或 function内皆可使用,只要变量名称相同所使用的就是同一个变量,直到程序结束.</p>
<p>因递归函数内部的变量, 会因它调用子函数(本身)而重复使用,故编写该类函数时, 应特别留心.</p>
<p>[例如:] 执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    x = 35</div><div class="line">    y = 45</div><div class="line">    test_variable( x )</div><div class="line">    printf("Return to main : arg1= %d, x= %d, y= %d, z= %d\n", arg1, x, y, z)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function test_variable( arg1 )</div><div class="line">&#123;</div><div class="line">    arg1++ # arg1 为参数列上的参数, 是local variable. 离开此函数后将消失.</div><div class="line">    y ++ # 会改变主式中的变量 y</div><div class="line">    z = 55 # z 为该函数中新使用的变量, 主程序中变量 z 仍可被使用.</div><div class="line">    printf("Inside the function: arg1=%d,x=%d, y=%d, z=%d\n", arg1, x, y, z)</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>结果屏幕印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Inside the function: arg1=36,x=35, y=46, z=55</div><div class="line">Return to main : arg1= 0, x= 35, y= 46, z= 55</div></pre></td></tr></table></figure></p>
<p>由上可知:<br>函数内可任意使用主程序中的任何变量.函数内所启用的任何变量(除参数外), 于该函数之外依然可以使用.此特性优劣参半, 最大的坏处是式中的变量不易被保护, 特别是递归调用本身, 执行子函数时会破坏父函数内的变量.</p>
<p>一个变通的方法是: 在函数的参数列中虚列一些参数. 函数执行中使用这些虚列的参数来记录不想被破坏的数据,如此执行子函数时就不会破坏到这些数据. 此外 awk 并不会检查调用函数时所传递的参数个数是否一致.</p>
<p>例如，定义递归函数如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> demo( arg1 ) &#123; <span class="comment"># 最常见的错误例子</span></div><div class="line">    ........</div><div class="line">    <span class="keyword">for</span>(i=1; i&lt; 20 ; i++)&#123;</div><div class="line">        demo(x)</div><div class="line">        <span class="comment"># 又呼叫本身. 因为 i 是 global variable, 故执行完该子函数后</span></div><div class="line">        <span class="comment"># 原函数中的 i 已经被坏, 故本函数无法正确执行.</span></div><div class="line">        .......</div><div class="line">    &#125;</div><div class="line">    ..........</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可将上列函数中的<code>i</code>虚列在该函数的参数列上, 如此<code>i</code>便是一个局部变量, 不会因执行子函数而被破坏.</p>
<p>将上列函数修改如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> demo( arg1, i )</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">for</span>(i=1; i&lt; 20; i++)</div><div class="line">    &#123;</div><div class="line">        demo(x)<span class="comment">#awk不会检查呼叫函数时, 所传递的参数个数是否一致</span></div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>$0</code>, <code>$1</code>,.., <code>NF</code>, <code>NR</code>,..也都是 global variable, 读者于递归函数中若有使用这些内建变量, 也应另外设立一些局部变量来保存,以免被破坏.</p>
<p>[范例:]以下是一个常见的递归调用范例. 它要求使用者输入一串元素(各元素间用空白隔开) 然后印出这些元素所有可能的排列.</p>
<p>编辑如下的awk式, 取名为 <code>permu</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    print "请输入排列的元素,各元素间请用空白隔开"</div><div class="line">    getline</div><div class="line">    permutation($0, "")</div><div class="line">    printf("\n共 %d 种排列方式\n", counter)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function permutation( main_lst, buffer,     new_main_lst, nf, i, j )</div><div class="line">&#123;</div><div class="line">    $0 = main_lst # 把main_lst指定给$0之后awk将自动进行字段分割.</div><div class="line">    nf = NF # 故可用 NF 表示 main_lst 上存在的元素个数.</div><div class="line">    # BASE CASE : 当main_lst只有一个元素时.</div><div class="line">    if( nf == 1)&#123;</div><div class="line">        print buffer main_lst #buffer的内容再加上main_lst就是完成一次排列的结果</div><div class="line">        counter++</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    # General Case : 每次从 main_lst 中取出一个元素放到buffer中</div><div class="line">    # 再用 main_lst 中剩下的元素 (new_main_lst) 往下进行排列</div><div class="line">    else for( i=1; i&lt;=nf ;i++)</div><div class="line">    &#123;</div><div class="line">        $0 = main_lst # $0为全局变量已被破坏, 故重新把main_lst赋给$0,令awk再做一次字段分割</div><div class="line">        new_main_lst = ""</div><div class="line">        for(j=1; j&lt;=nf; j++) # 连接 new_main_lst</div><div class="line">            if( j != i ) new_main_lst = new_main_lst " " $j</div><div class="line">        permutation( new_main_lst, buffer " " $i )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./permu</div></pre></td></tr></table></figure></p>
<p>屏幕上出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请输入排列的元素,各元素间请用空白隔开</div></pre></td></tr></table></figure></p>
<p>若输入 <code>1 2 3</code> 回车,结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> 1 2 3</div><div class="line"> 1 3 2</div><div class="line"> 2 1 3</div><div class="line"> 2 3 1</div><div class="line"> 3 1 2</div><div class="line"> 3 2 1</div><div class="line"></div><div class="line">共 6 种排列方式</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>有些较旧版的awk,并不容许使用者指定<code>$0</code>之值. 此时可改用gawk, 或 nawk.否则也可自行使用<code>split()</code>函数来分割<code>main_lst</code>.<br>为避免执行子函数时破坏<code>new_main_lst, nf, i, j</code>故把这些变量也列于参数列上. 如此,<code>new_main_lst, nf, i, j</code> 将被当成局部变量,而不会受到子函数中同名的变量影响. 读者声明函数时,参数列上不妨将这些 “虚列的参数” 与真正用于传递信息的参数间以较长的空白隔开, 以便于区别.<br>awk 中欲将字符串<code>concatenation</code>(连接)时, 直接将两字符串并置即可(Implicit Operator).</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN&#123;</div><div class="line">    A = "This "</div><div class="line">    B = "is a "</div><div class="line">    C = A B "key." # 变量A与B之间应留空白,否则"AB"将代表另一新变量.</div><div class="line">    print C</div><div class="line">&#125; '</div></pre></td></tr></table></figure></p>
<p>结果将印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">This is a key.</div></pre></td></tr></table></figure></p>
<p>awk使用者所编写的函数可再重用, 并不需要每个awk式中都重新编写.<br>将函数部分单独编写于一文件中, 当需要用到该函数时再以下列方式include进来.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> 函数文件名 <span class="_">-f</span> awk主程序文件名 数据文件文件名</div></pre></td></tr></table></figure></p>
<h2 id="附录-A-──-Pattern"><a href="#附录-A-──-Pattern" class="headerlink" title="附录 A ── Pattern"></a>附录 A ── Pattern</h2><p>awk 通过判断 Pattern 之值来决定是否执行其后所对应的Actions.这里列出几种常见的Pattern:</p>
<h3 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h3><p><code>BEGIN</code> 为 awk 的保留字, 是一种特殊的 Pattern.<br><code>BEGIN</code> 成立(其值为true)的时机是: “awk 程序一开始执行, 尚未读取任何数据之前.” 所以在<code>BEGIN { Actions }</code>语法中, 其 Actions 部份仅于程序一开始执行时被执行一次. 当 awk 从数据文件读入数据行后, BEGIN 便不再成立, 故不论有多少数据行, 该 Actions 部份仅被执行一次.</p>
<p>一般常把 “与数据文件内容无关” 与 “只需执行ㄧ次” 的部分置于该Actions(以 <code>BEGIN</code> 为 Pattern)中.</p>
<p>例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">    FS = <span class="string">"[ \t:]"</span> <span class="comment"># 于程序一开始时, 改变awk切割字段的方式</span></div><div class="line">    RS = <span class="string">""</span> <span class="comment"># 于程序一开始时, 改变awk分隔数据行的方式</span></div><div class="line">    count = 100 <span class="comment"># 设定变量 count 的起始值</span></div><div class="line">    <span class="built_in">print</span> <span class="string">" This is a title line "</span> <span class="comment"># 印出一行 title</span></div><div class="line">&#125;</div><div class="line">....... <span class="comment"># 其它 Pattern &#123; Actions &#125; .....</span></div></pre></td></tr></table></figure></p>
<p>有些awk程序甚至”不需要读入任何数据行”. 遇到这情况可把整个程序置于以 <code>BEGIN</code> 为 Pattern 的 Actions 中.</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; <span class="built_in">print</span> <span class="string">" Hello ! the Word ! "</span> &#125;</div></pre></td></tr></table></figure></p>
<p>注意: 执行该类仅含<code>BEGIN { Actions }</code>的程序时, awk 并不会开启任何数据文件进行处理.</p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p><code>END</code> 为 awk 的保留字, 是另一种特殊的 Pattern.<br><code>END</code> 成立(其值为true)的时机与 <code>BEGIN</code> 恰好相反, 为:”awk 处理完所有数据, 即将离开程序时”平常读入数据行时, END并不成立, 故其对应的 Actions 并不被执行; 唯有当awk读完所有数据时, 该 Actions 才会被执行</p>
<p>注意 : 不管数据行有多少笔, 该 Actions 仅被执行一次.</p>
<h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>使用像 “A 关系运算符 B” 的表达式当成 Pattern.<br>当 A 与 B 存在所指定的关系(Relation)时, 该 Pattern 就算成立(true).</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length(<span class="variable">$0</span>) &lt;= 80 &#123; <span class="built_in">print</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上式中<code>length($0)&lt;= 80</code>是一个 Pattern, 当<code>$0</code>(数据行)之长度小于等于80时该 Pattern 之值为true, 将执行其后的 Action (打印该数据行).</p>
<p>awk 中提供下列 关系运算符(Relation Operator)</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含意</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于或等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于或等于</td>
</tr>
<tr>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>~</td>
<td>match</td>
</tr>
<tr>
<td>!~</td>
<td>not match</td>
</tr>
</tbody>
</table>
<p>上列关系运算符除<code>~</code>(match)与<code>!~</code>(not match)外与 C 语言中之含意一致.</p>
<p><code>~</code>(match) 与<code>!~</code>(match) 在 awk 之含意简述如下:<br>若 A 为一字符串, B 为一正则表达式.<br><code>A ~B</code> 判断 字符串A 中是否 包含 能匹配(match)B式样的子字符串.<br><code>A !~B</code> 判断 字符串A 中是否 未包含 能匹配(match)B式样的子字符串.  </p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`<span class="variable">$0</span> ~ /program[0-9]+\.c/ &#123; <span class="built_in">print</span> <span class="variable">$0</span> &#125;`</div></pre></td></tr></table></figure></p>
<p><code>$0 ~ /program[0-9]+\.c/</code> 整个是一个 Pattern, 用来判断<code>$0</code>(数据行)中是否含有可 match <code>/program[0-9]+\.c/</code> 的子字符串, 若<code>$0</code>中含有该类字符串, 则执行 <code>print</code> (打印该行数据).</p>
<p>Pattern 中被用来比对的字符串为 <code>$0</code> 时(如本例), 可仅以正则表达式部分表示整个Pattern.</p>
<p>故本例的 Pattern 部分<code>$0 ~/program[0-9]+\.c/</code>可仅用<code>/program[0-9]+\.c/</code>表之(有关匹配及正则表达式请参考 附录 E )</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>直接使用正则表达式当成 Pattern; 此为 <code>$0 ~ 正则表达式</code> 的简写.<br>该 Pattern 用以判断<code>$0</code>(数据行) 中是否含有匹配该正则表达式的子字符串; 若含有该成立(true) 则执行其对应的 Actions.</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`/^[0-9]*$/ &#123; <span class="built_in">print</span> <span class="string">"This line is a integer !"</span> &#125;`</div></pre></td></tr></table></figure></p>
<p>与<code>$0 ~/^[0-9]*$/ { print &quot;This line is a integer !&quot; }</code> 相同</p>
<h3 id="混合-Pattern"><a href="#混合-Pattern" class="headerlink" title="混合 Pattern"></a>混合 Pattern</h3><p>之前所介绍的各种 Patterns, 其计算后结果为一逻辑值(True or False).awk 中逻辑值彼此间可通过<code>&amp;&amp;</code>(and), <code>||</code>(or),  <code>!</code>(not) 结合成一个新的逻辑值.故不同 Patterns 彼此可通过上述结合符号来结合成一个新的 Pattern. 如此可进行复杂的条件判断.</p>
<p>例 如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FNR &gt;= 23 &amp;&amp; FNR &lt;= 28 &#123; <span class="built_in">print</span> <span class="string">"     "</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上式利用<code>&amp;&amp;</code>(and) 将两个 Pattern 求值的结果合并成一个逻辑值.<br>该式将数据文件中 第23行 到 28行 向右移5格(先输出5个空白字符)后输出.<br>(<code>FNR</code>为awk的内建变量, 请参考 附录 D )</p>
<h3 id="Pattern1-Pattern2"><a href="#Pattern1-Pattern2" class="headerlink" title="Pattern1, Pattern2"></a>Pattern1, Pattern2</h3><p>遇到这种 Pattern, awk 会帮您设立一个 switch(或flag).<br>当awk读入的数据行使得 Pattern1 成立时, awk 会打开(turn on)这 switch.<br>当awk读入的数据行使得 Pattern2 成立时, awk 会关上(turn off)这个 switch.  </p>
<p>该 Pattern 成立的条件是:<br>当这个 switch 被打开(turn on)时 (包括 Pattern1, 或 Pattern2 成立的情况)</p>
<p>例 如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FNR &gt;= 23 &amp;&amp; FNR &lt;= 28 &#123; <span class="built_in">print</span> <span class="string">"     "</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>可改写为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FNR == 23 , FNR == 28 &#123; <span class="built_in">print</span> <span class="string">"     "</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>说明:<br>当 <code>FNR &gt;= 23</code> 时, awk 就 turn on 这个 switch; 因为随着数据行的读入, awk不停的累加<code>FNR</code>. 当<code>FNR = 28</code>时,<code>Pattern2 (FNR == 28)</code> 便成立, 这时 awk 会关上这个 switch.<br>当 switch 打开的期间, awk 会执行 <code>print &quot;     &quot; $0</code><br>( FNR 为awk的内建变量, 请参考 附录 D )</p>
<h2 id="附录-B-──-Actions"><a href="#附录-B-──-Actions" class="headerlink" title="附录 B ── Actions"></a>附录 B ── Actions</h2><p>Actions 是由下列指令(statement)所组成:</p>
<ul>
<li>表达式 (function calls, assignments..)</li>
<li>print 表达式列表</li>
<li>printf(格式化字符串, 表达式列表)</li>
<li>if( 表达式 ) 语句 [else 语句]</li>
<li>while( 表达式 ) 语句</li>
<li>do 语句 while( 表达式 )</li>
<li>for( 表达式; 表达式; 表达式 ) 语句</li>
<li>for( variable in array ) 语句</li>
<li>delete</li>
<li>break</li>
<li>continue</li>
<li>next</li>
<li>exit [表达式]</li>
<li>语句</li>
</ul>
<p>awk 中大部分指令与 C 语言中的用法一致, 此处仅介绍较为常用或容易混淆的指令的用法.</p>
<h3 id="流程控制指令"><a href="#流程控制指令" class="headerlink" title="流程控制指令"></a>流程控制指令</h3><p><strong>if 指令</strong></p>
<p>语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (表达式) 语句1 [<span class="keyword">else</span> 语句2 ]</div></pre></td></tr></table></figure></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( <span class="variable">$1</span> &gt; 25 )</div><div class="line">    <span class="built_in">print</span> <span class="string">"The 1st field is larger than 25"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"The 1st field is not larger than 25"</span></div></pre></td></tr></table></figure></p>
<p>(a) 与 C 语言中相同, 若 表达式 计算(evaluate)后之值不为 0 或空字符串, 则执行 语句1; 否则执行 语句2.<br>(b) 进行逻辑判断的表达式所返回的值有两种, 若最后的逻辑值为<code>true</code>, 则返回1, 否则返回0.<br>(c) 语法中<code>else 语句2</code>以 [ ] 前后括住表示该部分可视需要而予加入或省略.</p>
<p><strong>while 指令</strong></p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>( 表达式 ) 语句</div></pre></td></tr></table></figure></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(match(buffer,/[0-9]+\.c/)) &#123;</div><div class="line">    <span class="built_in">print</span> <span class="string">"Find :"</span> substr( buffer,RSTART, RLENGTH)</div><div class="line">    buff = substr( buffer, RSTART + RLENGTH)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上列范例找出 <code>buffer</code> 中所有能匹配 <code>/[0-9]+.c/</code>(数字之后接上 “<code>.c</code>“的所有子字符串).</p>
<p>范例中 <code>while</code> 以函数 <code>match()</code> 所返回的值做为判断条件. 若 <code>buffer</code> 中还含有匹配指定条件的子字符串(match成功), 则 <code>match()</code> 函数返回<code>1</code>, <code>while</code> 将持续进行其后的语句.</p>
<p><strong>do-while 指令</strong></p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> 语句 <span class="keyword">while</span>(表达式)</div></pre></td></tr></table></figure></p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    <span class="built_in">print</span> <span class="string">"Enter y or n ! "</span></div><div class="line">    getline data</div><div class="line">&#125; <span class="keyword">while</span>( data !~ /^[YyNn]$/)</div></pre></td></tr></table></figure></p>
<p>(a) 上例要求用户从键盘上输入一个字符, 若该字符不是Y, y, N, 或 n则会不停执行该循环, 直到读取正确字符为止.<br>(b) <code>do-while</code> 指令与 <code>while</code> 指令最大的差异是: <code>do-while</code> 指令会先执行<code>statement</code>而后再判断是否应继续执行. 所以, 无论如何其 <code>statement</code> 部分至少会执行一次.</p>
<p><strong>for Statement 指令(一)</strong></p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(variable <span class="keyword">in</span>  array ) statement</div></pre></td></tr></table></figure></p>
<p>范例: 执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">    BEGIN&#123;</div><div class="line">        X[1]= 50; X[2]= 60; X["last"]= 70</div><div class="line">        for( any in X )</div><div class="line">            printf("X[%s] = %d\n", any, X[any] )</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>结果输出 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X[last] = 70</div><div class="line">X[1] = 50</div><div class="line">X[2] = 60</div></pre></td></tr></table></figure></p>
<p>(a) 这个 <code>for</code> 指令, 专用以查找数组中所有的下标值, 并依次使用所指定的变量予以记录. 以本例而言, 变量 any 将逐次代表 “last”, 1 及2 .<br>(b) 以这个 <code>for</code> 指令, 所查找出的下标之值彼此间并无任何次续关系.<br>(c) 第5节中有该指令的使用范例, 及解说.</p>
<p><strong>for Statement 指令(二)</strong></p>
<p>语法 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(expression1; expression2; expression3) statement</div></pre></td></tr></table></figure></p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(ｉ=1; i&lt; =10; i++)  sum = sum + i</div></pre></td></tr></table></figure></p>
<p>说明:<br>(a) 上列范例用以计算 1 加到 10 的总和.<br>(b) <code>expression1</code> 常用于设定该 for 循环的起始条件, 如上例中的 <code>i=1</code><br><code>expression2</code> 用于设定该循环的停止条件, 如上例中的 <code>i &lt;= 10</code><br><code>expression3</code> 常用于改变 counter 之值, 如上例中的 <code>i++</code></p>
<p><strong>break 指令</strong></p>
<p><code>break</code> 指令用以强迫中断(跳离) <code>for</code>, <code>while</code>, <code>do-while</code> 等循环.</p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(  getline &lt; <span class="string">"datafile"</span> &gt; 0 )</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( <span class="variable">$1</span> == 0 )</div><div class="line">        <span class="built_in">break</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">print</span> <span class="variable">$2</span> / <span class="variable">$1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上例中, awk 不断地从文件 <code>datafile</code> 中读取资料, 当<code>$1</code>等于0时,就停止该执行循环.</p>
<p><strong>continue 指令</strong></p>
<p>循环中的 <code>statement</code> 进行到一半时, 执行 <code>continue</code> 指令来略过循环中尚未执行的<code>statement</code>.</p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( index <span class="keyword">in</span> X_array)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( index !~ /[0-9]+/ )  <span class="built_in">continue</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"There is a digital index"</span>, index</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上例中若 <code>index</code> 不为数字则执行<code>continue</code>, 故将略过(不执行)其后的指令.</p>
<p>需留心 <code>continue</code> 与 <code>break</code> 的差异 : 执行 <code>continue</code> 只是掠过其后未执行的<code>statement</code>, 但并未跳离开该循环.</p>
<p><strong>next 指令</strong></p>
<p>执行 <code>next</code> 指令时, awk 将掠过位于该指令(next)之后的所有指令(包括其后的所有<code>Pattern { Actions }</code>), 接著读取下一笔数据行,继续从第一个 <code>Pattern {Actions}</code> 执行起.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/^[ \t]*$/  &#123;  <span class="built_in">print</span> <span class="string">"This is a blank line! Do nothing here !"</span></div><div class="line">    next</div><div class="line">&#125;</div><div class="line"><span class="variable">$2</span> != 0 &#123; <span class="built_in">print</span> <span class="variable">$1</span>, <span class="variable">$1</span>/<span class="variable">$2</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上例中, 当 awk 读入的数据行为空白行时( match <code>/^[ \]*$/</code> ),除打印消息外只执行<code>next</code>, 故 awk 将略过其后的指令, 继续读取下一笔资料, 从头(第一个 <code>Pattern { Actions }</code>)执行起.</p>
<p><strong>exit 指令</strong></p>
<p>执行 <code>exit</code> 指令时, awk将立刻跳离(停止执行)该awk程序.</p>
<h3 id="awk-中的-I-O-指令"><a href="#awk-中的-I-O-指令" class="headerlink" title="awk 中的 I/O 指令"></a>awk 中的 I/O 指令</h3><p><strong>printf 指令</strong></p>
<p>该指令与 C 语言中的用法相同, 可借由该指令控制资料输出时的格式.</p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"format"</span>, item1, item2,.. )</div></pre></td></tr></table></figure></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id = <span class="string">"BE-2647"</span>;  ave = 89</div><div class="line"><span class="built_in">printf</span>(<span class="string">"ID# : %s   Ave Score : %d\n"</span>, id, ave)</div></pre></td></tr></table></figure></p>
<p>(a) 结果印出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ID# : BE-2647   Ave Score : 89</div></pre></td></tr></table></figure></p>
<p>(b) <code>format</code> 部分是由 一般的字串(String Constant) 及 格式控制字符(Formatcontrol letter, 其前会加上一个%字符)所构成. 以上式为例”<code>ID# :</code>“ 及 “<code>Ave Score :</code>“为一般字串.<code>%s</code> 及 <code>%d</code> 为格式控制字符.<br>(c) 打印时, 一般字串将被原封不动地打印出来. 遇到格式控制字符时,则依序把<code>format</code>后方之 <code>item</code> 转换成所指定的格式后进行打印.<br>(d) 有关的细节, 读者可从介绍 C 语言的书籍上得到较完整的介绍.</p>
<p>(e) <code>print</code>及<code>printf</code>两个指令, 其后可使用 <code>&gt;</code>或<code>&gt;&gt;</code>将输出到 <code>stdout</code> 的数据重定向到其它文件, 7.1 节中有完整的</p>
<p><strong>print 指令</strong></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id = <span class="string">"BE-267"</span>;  ave = 89</div><div class="line"><span class="built_in">print</span> <span class="string">"ID# :"</span>, id, <span class="string">"Ave Score :"</span>ave</div></pre></td></tr></table></figure></p>
<p>(a) 结果印出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ID# : BE-267 Ave Score :89</div></pre></td></tr></table></figure></p>
<p>(b) <code>print</code> 之后可接上字串常数(Constant String)或变量. 它们彼此间可用”,” 隔开.<br>(c) 上式中, 字串 “ID# :” 与变量 id 之间使用”<code>,</code>“隔开, 打印时两者之间会以自动<code>OFS</code>(请参考 附录D 內建变量<code>OFS</code>) 隔开. <code>OFS</code> 之值一般內定为 “一个空格”<br>(d) 上式中, 字串”<code>Ave Score :</code>“与变量<code>ave</code>之间并未以”<code>,</code>“隔开, awk会将这两者先当成字串concate在一起(变成”<code>Ave Score :89</code>“)后,再予打印</p>
<p><strong>getline 指令</strong></p>
<p>语法</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>由何处读取数据</th>
<th>数据读入后置于</th>
</tr>
</thead>
<tbody>
<tr>
<td>getline var <code>&lt;</code> file</td>
<td>所指定的 file</td>
<td>变量 var(var省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td>pipe 变量</td>
<td>变量 var(var省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td>见 注一</td>
<td>变量 var(var省略时,表示置于<code>$0</code>)</td>
</tr>
</tbody>
</table>
<p><code>getline</code> 一次读取一行资料, 若读取成功则<code>return 1</code>,若读取失败则<code>return -1</code>, 若遇到文件结束(EOF), 则return 0</p>
<p><strong>close  指令</strong></p>
<p>该指令用以关闭一个打开的文件, 或 pipe (见下例)</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;  <span class="built_in">print</span> <span class="string">"ID #   Salary"</span> &gt; <span class="string">"data.rpt"</span> &#125;</div><div class="line">&#123;  <span class="built_in">print</span> <span class="variable">$1</span> , <span class="variable">$2</span> * <span class="variable">$3</span>  | <span class="string">"sort -k 1 &gt; data.rpt"</span> &#125;</div><div class="line">END&#123;  close( <span class="string">"data.rpt"</span> )</div><div class="line">    close( <span class="string">"sort -k 1 &gt; data.rpt"</span> )</div><div class="line">    <span class="built_in">print</span> <span class="string">" There are"</span>, NR, <span class="string">"records processed."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明:<br>(a) 上例中, 一开始执行<code>print &quot;ID #   Salary&quot; &gt; &quot;data.rpt&quot;</code>指令来输出一行抬头. 它使用 I/O Redirection (<code>&gt;</code>)将数据转输出到<code>data.rpt</code>, 故此时文件 <code>data.rpt</code> 是处於 Open 状态.<br>(b) 指令<code>print $1, $2 * $3</code> 不停的将输出的资料送往 pipe(<code>|</code>), awk在程序将结束时才会呼叫 shell 使用指令<code>&quot;sort -k 1 &gt; data.rpt&quot;</code> 来处理 pipe 中的数据; 并未立即执行, 这点与 Unix 中pipe的用法不尽相同.<br>(c) 最后希望於文件 <code>data.rpt</code> 的末尾处加上一行 “There are…..”.但此时, Shell尚未执行<code>&quot;sort -k 1 &gt; data.rpt&quot;</code> 故各数据行排序后的 ID 及 Salary 等数据尚未写入<code>data.rpt</code>. 所以得命令 awk 提前先通知 Shell 执行命令<code>&quot;sort -k 1 &gt; data.rpt&quot;</code> 来处理 pipe 中的资料. awk中这个动作称为 close pipe. 是由执行<code>close ( &quot;shell command&quot; )</code>来完成. 需留心 <code>close( )</code>指令中的 shell command 需与”<code>|</code>“后方的 shell command 完全相同(一字不差), 较佳的方法是先以该字串定义一个简短的变量, 程序中再以此变量代替该shell command<br>(d) 为什么执行 <code>close(&quot;data.rpt&quot;)</code> ?  因为 <code>sort</code> 完后的资料也将写到<code>data.rpt</code>,而该文件正为awk所打开使用(write)中, 故awk程式中应先关闭<code>data.rpt</code>. 以免造成因二个 processes 同时打开一个文件进行输出(write)所产生的错误.</p>
<p><strong>system 指令</strong></p>
<p>该指令用以执行Shell上的 command.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DataFile = <span class="string">"invent.rpt"</span></div><div class="line">system( <span class="string">"rm "</span> DataFile )</div></pre></td></tr></table></figure></p>
<p>说明:<br>(a) <code>system(&quot;字符串&quot;)</code>指令接受一个字符串当成Shell的命令. 上例中, 使用一个字串常数”<code>rm</code>“ 连接(concate)一个变量 <code>DataFile</code> 形成要求 Shell 执行的命令.Shell 实际执行的命令为 “<code>rm invent.rpt</code>“.</p>
<p><strong>“<code>|</code>“ pipe指令</strong></p>
<p>“<code>|</code>“ 配合 awk 输出指令, 可把 output 到 stdout 的资料继续转送给Shell 上的某一命令当成input的资料.</p>
<p>“<code>|</code>“  配合 awk <code>getline</code> 指令, 可呼叫 Shell 执行某一命令, 再以 awk 的 <code>getline</code> 指令将该命令的所产生的资料读进 awk 程序中.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">print</span> <span class="variable">$1</span>, <span class="variable">$2</span> * <span class="variable">$3</span>  | <span class="string">"sort -k 1 &gt; result"</span> &#125;</div><div class="line"><span class="string">"date"</span> |  getline  Date_data</div></pre></td></tr></table></figure></p>
<p>读者请参考7.2 节,其中有完整的范例说明.</p>
<h3 id="awk-释放所占用的记忆体的指令"><a href="#awk-释放所占用的记忆体的指令" class="headerlink" title="awk 释放所占用的记忆体的指令"></a>awk 释放所占用的记忆体的指令</h3><p>awk 程式中常使用数组(Array)来记忆大量数据, <code>delete</code> 指令便是用来释放数组中的元素所占用的内存空间.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( any <span class="keyword">in</span> X_arr )</div><div class="line">    delete X_arr[any]</div></pre></td></tr></table></figure></p>
<p>读者请留心, <code>delete</code> 指令一次只能释放数组中的一个元素.</p>
<h3 id="awk-中的数学运算符-Arithmetic-Operators"><a href="#awk-中的数学运算符-Arithmetic-Operators" class="headerlink" title="awk 中的数学运算符(Arithmetic Operators)"></a>awk 中的数学运算符(Arithmetic Operators)</h3><p>+(加), -(減), *(乘), /(除), %(求余数), ^(指数) 与 C 语言中用法相同</p>
<h3 id="awk-中的赋值运算符-Assignment-Operators"><a href="#awk-中的赋值运算符-Assignment-Operators" class="headerlink" title="awk 中的赋值运算符(Assignment Operators)"></a>awk 中的赋值运算符(Assignment Operators)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">=, +=, -=, *= , /=, %=, ^=</div></pre></td></tr></table></figure>
<p><code>x += 5</code> 的意思为<code>x = x + 5</code>, 其余类推.</p>
<h3 id="awk-中的条件运算符-Conditional-Operator"><a href="#awk-中的条件运算符-Conditional-Operator" class="headerlink" title="awk 中的条件运算符(Conditional  Operator)"></a>awk 中的条件运算符(Conditional  Operator)</h3><p>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">判断条件 ? value1 : value2</div></pre></td></tr></table></figure></p>
<p>若 判断条件 成立(true) 则返回 value1, 否则返回 value2.</p>
<h3 id="awk-中的逻辑运算符-Logical-Operators"><a href="#awk-中的逻辑运算符-Logical-Operators" class="headerlink" title="awk 中的逻辑运算符(Logical Operators)"></a>awk 中的逻辑运算符(Logical Operators)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;&amp;( and ), ||(or), !(not)</div></pre></td></tr></table></figure>
<p>Extended Regular Expression 中使用 “<code>|</code>“ 表示 or 请勿混淆.</p>
<h3 id="awk-中的关系运算符-Relational-Operators"><a href="#awk-中的关系运算符-Relational-Operators" class="headerlink" title="awk 中的关系运算符(Relational Operators)"></a>awk 中的关系运算符(Relational Operators)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;, &gt;=, &lt;, &lt; =, ==, !=, ~, !~</div></pre></td></tr></table></figure>
<h3 id="awk-中其它的运算符"><a href="#awk-中其它的运算符" class="headerlink" title="awk 中其它的运算符"></a>awk 中其它的运算符</h3><p>+(正号), -(负号),  ++(Increment Operator), –(Decrement Operator)</p>
<h3 id="awk-中各运算符的运算级"><a href="#awk-中各运算符的运算级" class="headerlink" title="awk 中各运算符的运算级"></a>awk 中各运算符的运算级</h3><p>按优先高低排列:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$</code></td>
<td>(栏位运算元, 例如: <code>i=3</code>; <code>$i</code>表示第3栏)</td>
</tr>
<tr>
<td>^</td>
<td>(指数运算)</td>
</tr>
<tr>
<td>+, -, !</td>
<td>(正,负号,及逻辑上的 not)</td>
</tr>
<tr>
<td>*, /, %</td>
<td>(乘,除,余数)</td>
</tr>
<tr>
<td>+, -</td>
<td>(加,減)</td>
</tr>
<tr>
<td>&gt;, &gt;=, <code>&lt;</code>, <code>&lt;=</code>, ==, !=</td>
<td>(关系运算符)</td>
</tr>
<tr>
<td>~, !~</td>
<td>(match, not match)</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>(逻辑上的 and)</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>(逻辑上的 or )</td>
</tr>
<tr>
<td>?:</td>
<td>(条件运算符)</td>
</tr>
<tr>
<td>=, +=, -=, *=, /=, %=, ^=</td>
<td>(赋值运算符)</td>
</tr>
</tbody>
</table>
<h2 id="附录C-──-awk-的內建函数-Built-in-Functions"><a href="#附录C-──-awk-的內建函数-Built-in-Functions" class="headerlink" title="附录C ── awk 的內建函数(Built-in Functions)"></a>附录C ── awk 的內建函数(Built-in Functions)</h2><h3 id="字串函数"><a href="#字串函数" class="headerlink" title="字串函数"></a>字串函数</h3><p><strong>index(原字串, 找寻的子字串)</strong></p>
<p>若原字串中含有欲找寻的子字串,则返回该子字串在原字串中第一次出现的位置,若未曾出现该子字串则返回<code>0</code>.</p>
<p>例如执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  <span class="string">'BEGIN&#123; print index("8-12-94","-") &#125;'</span></div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2</div></pre></td></tr></table></figure></p>
<p><strong>length(字串): 返回该字串的长度.</strong></p>
<p>例如执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  <span class="string">'BEGIN &#123; print length("John") &#125;'</span></div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4</div></pre></td></tr></table></figure></p>
<p><strong>match(原字串, 用以找寻比对的正则表达式)</strong></p>
<p>awk会在原字串中找寻合乎正则表达式的子字串. 若合乎条件的子字串有多个, 则以原字串中最左方的子字串为准.</p>
<p>awk找到该字串后会依此字串为依据进行下列动作:<br>设定awk內建变量<code>RSTART</code>,<code>RLENGTH</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> RSTART =  合条件的子字串在原字串中的位置.</div><div class="line">        =  0 ; 若未找到合条件的子字串.</div><div class="line"></div><div class="line">RLENGTH = 合条件的子字串长度.</div><div class="line">        = -1 ; 若未找到合条件的子字串.</div></pre></td></tr></table></figure></p>
<p>返回 <code>RSTART</code> 之值.</p>
<p>例如执行 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">' BEGIN &#123;</span></div><div class="line">    match( "banana", /(an)+/ )</div><div class="line">    print RSTART, RLENGTH</div><div class="line">&#125; '</div></pre></td></tr></table></figure></p>
<p>执行结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2 4</div></pre></td></tr></table></figure></p>
<p><strong>split(原字串, 数组名称, 分隔字符)</strong></p>
<p>awk将依所指定的分隔字符(field separator)来分隔原字串成一个个的栏位(field),并以指定的数组记录各个被分隔的栏位.</p>
<p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArgLst = &quot;5P12p89&quot;</div><div class="line">split(ArgLst, Arr, /[Pp]/)</div></pre></td></tr></table></figure></p>
<p>执行后: Arr[1]=5,  Arr[2]=12,  Arr[3]=89</p>
<p><strong>sprintf(格式字符串, 项1, 项2, …)</strong></p>
<p>该函数的用法与 awk 或 C 的输出函数<code>printf()</code>相同. 所不同的是<code>sprintf()</code>会将要求印出的结果当成一个字串返回. 一般最常使用<code>sprintf()</code>来改变资料格式. 如: x 为一数值资料, 若欲将其变成一个含二位小数的资料,可执行如下指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = 28</div><div class="line">x = sprintf(<span class="string">"%.2f"</span>,x)</div></pre></td></tr></table></figure></p>
<p>执行后 <code>x = &quot;28.00&quot;</code></p>
<p><strong>sub(比对用的正则表达式, 将替換的新字串, 原字串)</strong></p>
<p><code>sub()</code>将原字串中第一个(最左边)合乎所指定的正则表达式的子字串改以新字串取代.<br>第二个参数”将替換的新字串”中可用”<code>&amp;&quot;</code>来代表”合於条件的子字串”</p>
<p>承上例,执行下列指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = <span class="string">"a6b12anan212.45an6a"</span></div><div class="line">sub( /(an)+[0-9]*/, <span class="string">"[&amp;]"</span>, A)</div><div class="line"><span class="built_in">print</span> A</div></pre></td></tr></table></figure></p>
<p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ab12[anan212].45an6a</div></pre></td></tr></table></figure></p>
<p><code>sub()</code>不仅可执行替换(replacement)的功用,当第二个参数为空字串(“”)时,<code>sub()</code>所执行的是”去除指定字串”的功用.</p>
<p>通过<code>sub()</code>与<code>match()</code>的搭配使用,可逐次取出原字串中合乎指定条件的所有子字串.</p>
<p>例如执行下列程式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    data = "p12-P34 P56-p61"</div><div class="line">    while( match( data ,/[0-9]+/) &gt; 0) &#123;</div><div class="line">        print substr(data, RSTART, RLENGTH )</div><div class="line">        sub(/[0-9]+/,"",data)</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>结果输出 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">12</div><div class="line">34</div><div class="line">56</div><div class="line">61</div></pre></td></tr></table></figure></p>
<p><code>sub()</code>中第三个参数(原字串)若未指定,则其预设值为<code>$0</code>.<br>可用 <code>sub(/[9-0]+/,&quot;digital&quot;)</code> 表示<code>sub(/[0-9]+/,&quot;digital&quot;,$0 )</code></p>
<p><strong>gsub(比对用的正则表达式, 将替換的新字串, 原字串)</strong></p>
<p>这个函数与<code>sub()</code>一样,同样是进行字串取代的函数. 唯一不同点是</p>
<ul>
<li>gsub()会取代所有合条件的子字串.</li>
<li>gsub()会返回被取代的子字串个数.</li>
</ul>
<p>请参考<code>sub()</code>.</p>
<p><strong>substr(字串, 起始位置 [,长度])</strong></p>
<p>返回从起始位置起,指定长度的子字串. 若未指定长度,则返回起始位置到字串末尾的子字串.</p>
<p>执行下例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'BEGIN &#123; print substr("User:Wei-Lin Liu", 6)&#125;'</span></div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Wei-Lin Liu</div></pre></td></tr></table></figure></p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p><strong>int(x): 返回x的整数部分(去掉小数).</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int(7.8) 将返回 7</div><div class="line">int(-7.8) 将返回 -7</div></pre></td></tr></table></figure></p>
<p><strong>sqrt(x): 返回x的平方根.</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqrt(9) 将返回 3</div></pre></td></tr></table></figure></p>
<p>若 x 为负数,则执行<code>sqrt(x)</code>时将造成 Run Time Error [译者注: 我这里没有发生错误,返回的是”nan”]</p>
<p><strong>exp(x): 将返回e的x次方.</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exp(1) 将返回 2.71828</div></pre></td></tr></table></figure></p>
<p><strong>log(x): 将返回x以e为底的对数值.</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">log</span>(exp(1))  将返回 1</div></pre></td></tr></table></figure></p>
<p>若<code>x&lt; 0</code> ,则执行<code>sqrt(x)</code>时将造成 Run Time Error. [译者注: 我这里也没有发生错误,返回的是”nan”]</p>
<p><strong>sin(x): x 须以弧度为单位, sin(x)将返回x的sin函数值.</strong></p>
<p><strong>cos(x): x 须以弧度为单位, cos(x)将返回x的cos函数值</strong></p>
<p><strong>atan2(y,x): 返回 y/x 的tan反函数之值, 返回值系以弧度为单位.</strong></p>
<p><strong>rand(): 返回介于0与1之间的(近似)随机数值; 0 &lt; rand() &lt;1.</strong></p>
<p>除非使用者自行指定<code>rand()</code>函数起始的种子, 否则每次执行awk程式时, <code>rand()</code>函数都将使用同一个內定的种子,来产生随机数.</p>
<p><strong>srand([x]): 指定以<code>x</code>为<code>rand( )</code>函数起始的种子.</strong></p>
<p>若省略了<code>x</code>,则awk会以执行时的日期与时间为<code>rand()</code>函数起始的种子.</p>
<h2 id="附录D-──-awk-的內建变量-Built-in-Variables"><a href="#附录D-──-awk-的內建变量-Built-in-Variables" class="headerlink" title="附录D ── awk 的內建变量 Built-in Variables"></a>附录D ── awk 的內建变量 Built-in Variables</h2><p>因內建变量的个数不多, 此处按其相关性分类说明, 并未按其字母顺序排列.</p>
<p><strong>ARGC</strong></p>
<p>ARGC表示命令行上除了选项<code>-F</code>, <code>-v</code>, <code>-f</code> 及其所对应的参数之外的所有参数的个数.若将”awk程式”直接写於命令列上, 则 <code>ARGC</code> 亦不将该”程式部分”列入计算.</p>
<p><strong>ARGV</strong></p>
<p>ARGV数组用以记录命令列上的参数.</p>
<p>例: 执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  -F\t -v a=8 <span class="_">-f</span> prg.awk  file1.dat file2.dat</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  -F\t -v a=8 <span class="string">'&#123; print $1 * a &#125;'</span> file1.dat file2.dat</div></pre></td></tr></table></figure></p>
<p>执行上列任一程式后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ARGC    =  3</div><div class="line">ARGV[0] = &quot;awk&quot;</div><div class="line">ARGV[1] = &quot;file1.dat&quot;</div><div class="line">ARGV[2] = &quot;file2.dat&quot;</div></pre></td></tr></table></figure></p>
<p>读者请留心: 当 <code>ARGC = 3</code> 时, 命令列上仅指定了 2 个文件.</p>
<p>注:</p>
<p><code>-F\t</code> 表示以 <code>tab</code> 为栏位分隔字符 <code>FS</code>(field seporator).</p>
<p><code>-v a=8</code> 是用以初始化程序中的变量<code>a</code>.</p>
<p><strong>FILENAME</strong></p>
<p>FILENAME用以表示目前正在处理的文件档名.</p>
<p><strong>FS</strong></p>
<p>栏位分隔字符.</p>
<p><strong>$0</strong></p>
<p>表示目前awk所读入的数据行.</p>
<p><strong>$1,$2..</strong></p>
<p>分別表示所读入的数据行之第一栏, 第二栏,..</p>
<p>说明:<br>当awk读入一笔数据行 <code>&quot;A123  8:15&quot;</code> 时,会先以<code>$0</code>记录.<br>故 <code>$0 = &quot;A123  8:15&quot;</code></p>
<p>若程序中进一步使用了<code>$1</code>, <code>$2</code>.. 或 <code>NF</code> 等內建变量时, awk 才会自动分割<code>$0</code>.<br>以便取得栏位相关的资料. 切割后各个栏位的资料会分別以<code>$1</code>, <code>$2</code>, <code>$3</code>…予以记录.</p>
<p>awk內定(default)的 栏位分隔字符(<code>FS</code>) 为 空白字符(空格及tab).</p>
<p>以本例而言, 读者若未改变<code>FS</code>, 则分割后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一栏($1)=&quot;A123&quot;`,  第二栏($2)=&quot;8:15&quot;`.</div></pre></td></tr></table></figure></p>
<p>使用者可用正则表达式自行定义<code>FS</code>. awk每次需要分割数据行时, 会参考目前FS的值.</p>
<p>例如:<br>令<code>FS = &quot;[ :]+&quot;</code> 表示任何由 <code>空白&quot; &quot;</code> 或 <code>冒号&quot;:&quot;</code> 所组成的字串都可当成分隔字符, 则分割后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一栏($1) = &quot;A123&quot;, 第二栏($2) = &quot;8&quot;, 第三栏($3) = &quot;15&quot;</div></pre></td></tr></table></figure></p>
<p><strong>NR</strong></p>
<p>NR 表从 awk 开始执行该程序后所读取的数据行数.</p>
<p><strong>FNR</strong></p>
<p><code>FNR</code> 与 <code>NR</code> 功用类似. 不同的是awk每打开一个新的文件, <code>FNR</code> 便从 0 重新累计</p>
<p><strong>NF</strong></p>
<p>NF表目前的数据行所被切分的栏位数.</p>
<p>awk 每读入一笔资料后, 在程序中可以 <code>NF</code> 来得知该行数据包含的栏位个数.在下一笔资料被读入之前, <code>NF</code> 并不会改变. 但使用者若自行使用<code>$0</code>来记录数据,例如: 使用 <code>getline</code>, 此时 <code>NF</code> 将代表新的 <code>$0</code> 上所记载的资料的栏位个数.</p>
<p><strong>OFS</strong></p>
<p><code>OFS</code>输出时的栏位分隔字符. 预设值 <code>&quot; &quot;(一个空白)</code>, 详见下面说明.</p>
<p><strong>ORS</strong></p>
<p><code>ORS</code>输出时数据行的分隔字符. 预设值 <code>&quot;\n&quot;(跳行)</code>, 见下面说明.</p>
<p><strong>OFMT</strong></p>
<p><code>OFMT</code>数值资料的输出格式. 预设值”<code>%.6g</code>“(若须要时最多印出6位小数)</p>
<p>当使用 <code>print</code> 指令一次印出多项资料时,<br>例如: <code>print $1, $2</code><br>输出时, awk会自动在 <code>$1</code> 与 <code>$2</code> 之间补上一个 <code>OFS</code> 之值  </p>
<p>每次使用 <code>print</code> 输出后, awk 会自动补上 <code>ORS</code> 之值.</p>
<p>使用 <code>print</code> 输出数值数据时, awk 将采用 <code>OFMT</code> 之值为输出格式.<br>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'BEGIN &#123; print 2/3,1; OFS=":"; OFMT="%.2g"; print 2/3,1 &#125;'</span></div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0.666667 1</div><div class="line">0.67:1</div></pre></td></tr></table></figure></p>
<p>程序中通过改变<code>OFS</code>和<code>OFMT</code>的值, 改变了指令 <code>print</code> 的输出格式.</p>
<p><strong>RS</strong></p>
<p><code>RS</code> (Record Separator): awk从文件上读取资料时, 将根据 <code>RS</code> 的定义把资料切割成许多Records,而awk一次仅读入一个Record,以进行处理.</p>
<p><code>RS</code> 的预设值是 “<code>\n</code>“. 所以一般 awk 一次仅读入一行资料.</p>
<p>有时一个Record含括了几行资料(Multi-line Record). 这情況下不能再以”<code>\n</code>“来分隔相邻的Records, 可改用 <code>空白行</code> 来分隔.<br>在awk程式中,令 <code>RS = &quot;&quot;</code> 表示以 <code>空白行</code> 来分隔相邻的Records.</p>
<p><strong>RSTART</strong></p>
<p><code>RSTART</code>与使用字串函数<code>match()</code>有关的变量,详见下面说明.</p>
<p><strong>RLENGTH</strong></p>
<p><code>RLENGTH</code>与使用字串函数<code>match()</code>有关之变量.</p>
<p>当使用者使用 <code>match(...)</code> 函数后, awk会将 <code>match(...)</code> 执行的结果以<code>RSTART</code>, <code>RLENGTH</code> 记录.<br>请参考 附录 C awk的內建函数 match().</p>
<p><strong>SUBSEP</strong></p>
<p><code>SUBSEP</code>(Subscript Separator)数组下标的分隔字符,<br>预设值为”<code>\034</code>“实际上, awk中的 数组 只接受 <code>字串</code> 当它的下标,如: <code>Arr[&quot;John&quot;]</code>.</p>
<p>但使用者在 awk 中仍可使用 <code>数字</code> 当阵列的下标, 甚至可使用多维的数组<code>(Multi-dimenisional Array)</code>如: <code>Arr[2,79]</code></p>
<p>事实上, awk 在接受<code>Arr[2,79]</code> 之前, 就已先把其下标转换成字串<code>&quot;2\03479&quot;</code>, 之后便以<code>Arr[&quot;2\03479&quot;]</code>代替<code>Arr[2,79]</code>.</p>
<p>可参考下例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'BEGIN &#123;</span></div><div class="line">    Arr[2,79] = 78</div><div class="line">    print  Arr[2,79]</div><div class="line">    print  Arr[ 2 , 79 ]</div><div class="line">    print  Arr["2\03479"]</div><div class="line">    idx = 2 SUBSEP 79</div><div class="line">    print Arr[idx]</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行结果输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">78</div><div class="line">78</div><div class="line">78</div><div class="line">78</div></pre></td></tr></table></figure></p>
<h2 id="附录E-──-正则表达式-Regular-Expression-简介"><a href="#附录E-──-正则表达式-Regular-Expression-简介" class="headerlink" title="附录E ── 正则表达式(Regular Expression) 简介"></a>附录E ── 正则表达式(Regular Expression) 简介</h2><h3 id="为什么要使用正则表达式"><a href="#为什么要使用正则表达式" class="headerlink" title="为什么要使用正则表达式"></a>为什么要使用正则表达式</h3><p>UNIX 中提供了许多 指令 和 tools, 它们具有在文件中 查找(Search)字串或替换(Replace)字串 的功能. 像 grep, vi , sed, awk,…</p>
<p>不论是查找字串或替换字串, 都得先告诉这些指令所要查找(被替换)的字串为何.若未能预先明确知道所要查找(被替换)的字串为何, 只知该字串存在的范围或特征时,例如:<br>(一) 找寻 <code>&quot;T0.c&quot;</code>,<code>&quot;T1.c&quot;</code>,<code>&quot;T2.c&quot;</code>….<code>&quot;T9.c&quot;</code> 当中的任一字串.<br>(二) 找寻至少存在一个 “A” 的任意字串.<br>这情況下, 如何告知执行查找字串的指令所要查找的字串为何.<br>例 (一) 中, 要查找任一在 “<code>T</code>“ 与 “<code>.c</code>“ 之间存在一个阿拉伯数字的字串;当然您可以列举的方式, 一一把所要找寻的字串告诉执行命令的指令. 但例 (二) 中合乎该条件的字串有无限种可能, 势必无法一一列举.此时,便需要另一种字串表示的方法(协定).</p>
<h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式(以下简称 Regexp)是一种字串表达的方式. 可用以指定具有某特征的所有字串.<br>注: 为区別于一般字串, 本附录中代表 Regexp 的字串之前皆加 “Regexp”. awk 程式中常以<code>/..../</code>括住 <code>Regexp</code>; 以区別于一般字串.</p>
<h3 id="组成正则表达式的元素"><a href="#组成正则表达式的元素" class="headerlink" title="组成正则表达式的元素"></a>组成正则表达式的元素</h3><p>普通字符 除了<code>. * [ ] + ? ( ) \  ^ $</code>外之所有字符.</p>
<p>由普通字符所组成的Regexp其意义与原字串字面意义相同.<br>例如: Regexp “<code>the</code>“ 与一般字串的 “<code>the</code>“ 代表相同的意义.</p>
<p><code>.</code> (Meta character): 用以代表任意一字符.</p>
<p>须留心 UNIX Shell 中使用”<code>*</code>“表示 Wild card, 可用以代表任意长度的字串.而 Regexp 中使用 “<code>.</code>“ 来代表一个任意字符.(注意: 并非任意长度的字串)Regexp 中 “<code>*</code>“ 另有其它涵意, 并不代表任意长度的字串.</p>
<p><code>^</code> 表示该字串必须出现于行首.</p>
<p><code>$</code> 表示该字串必须出现于行末.</p>
<p>例如:<br>Regexp <code>/^The/</code> 用以表示所有出现于行首的字串 “<code>The</code>“.<br>Regexp <code>/The$/</code> 用以表示所有出现于行末字串 “<code>The</code>“.</p>
<p><code>\</code> 将特殊字符还原成字面意义的字符(Escape character)</p>
<p>Regexp 中特殊字符将被解释成特定的意义. 若要表示特殊字符的字面(literal meaning)意义时,在特殊字符之前加上”<code>\</code>“即可.</p>
<p>例如:<br>使用Regexp来表示字串 “a.out”时, 不可写成 <code>/a.out/</code>.</p>
<p>因为”<code>.</code>“是特殊字符, 表任一字符. 可符合 Regexp <code>/a.out/</code> 的字串将不只 “<code>a.out</code>“ 一个; 字串 “<code>a2out</code>“, “<code>a3out</code>“, “<code>aaout</code>“ …都符合 Regexp <code>/a.out/</code> 正确的用法为: <code>/a\.out/</code></p>
<p><code>[...]</code>字符集合, 用以表示两中括号间所有的字符当中的任一个.</p>
<p>例如:<br>Regexp <code>/[Tt]/</code> 可用以表示字符 “<code>T</code>“ 或 “<code>t</code>“. 故 Regexp <code>/[Tt]he/</code> 表示字串 “<code>The</code>“ 或 “<code>the</code>“.</p>
<p>字符集合 <code>[...]</code> 內不可随意留空白.</p>
<p>例如: Regexp <code>/[ Tt ]/</code> 其中括号內有空白字符, 除表示”<code>T</code>“, “<code>t</code>“ 中任一个字符, 也可代表一个 <code>&quot; &quot;(空白字符)</code></p>
<p><code>-</code> 字符集合中可使用 “<code>-</code>“ 来指定字符的区间, 其用法如下:<br>Regexp <code>/[0-9]/</code> 等价于 <code>/[0123456789]/</code> 用以表示任意一个阿拉伯数字.<br>同理 Regexp <code>/[A-Z]/</code> 用以表示任意一个大写英文字母.</p>
<p>但应留心:<br>Regexp <code>/[0-9a-z]/</code> 并不等于 <code>/[0-9][a-z]/</code>; 前者表示一个字符, 后者表示二个字符.<br>Regexp <code>/[-9]/</code> 或 <code>/[9-]/</code> 只代表字符 “<code>9</code>“或 “<code>-</code>“.</p>
<p><code>[^...]</code> 使用<code>[^..]</code>产生字符集合的补集(complement set).</p>
<p>其用法如下:<br>例如: 要指定 “<code>T</code>“ 或 “<code>t</code>“ 之外的任一个字符, 可用 <code>/[^Tt]/</code> 表之.<br>同理 Regexp <code>/[^a-zA-Z]/</code> 表示英文字母之外的任一个字符.</p>
<p>须留心 “<code>^</code>“ 的位置: “<code>^</code>“ 必须紧接於”<code>[</code>“之后, 才代表字符集合的补集<br>例如:Regexp <code>/[0-9\^]/</code> 只是用以表示一个阿拉伯数字或字符”<code>^</code>“.</p>
<p><code>*</code> 形容字符重复次数的特殊字符.</p>
<p>“<code>*</code>“ 形容它前方之字符可出现 1 次或多次, 或不出现(0次).</p>
<p>例如:<br>Regexp <code>/T[0-9]*\.c/</code> 中 <code>*</code> 形容其前 <code>[0-9]</code> (一个阿拉伯数字)出现的次数可为 0 次或 多次. 故Regexp <code>/T[0-9]*\.c/</code> 可用以表示”<code>T.c</code>“, “<code>T0.c</code>“, “<code>T1.c</code>“…”<code>T19.c</code>“</p>
<p><code>+</code> 形容其前的字符出现一次或一次以上.</p>
<p>例如:<br>Regexp <code>/[0-9]+/</code> 用以表示一位或一位以上的数字.</p>
<p><code>?</code> 形容其前的字符可出现一次或不出现.</p>
<p>例如:<br>Regexp <code>/[+-]?[0-9]+/</code> 表示数字(一位以上)之前可出现正负号或不出现正负号.</p>
<p><code>(...)</code> 用以括住一群字符,且将之视成一个group(见下面说明)</p>
<p>例如:<br>Regexp <code>/12+/</code> 表示字串 “<code>12</code>“, “<code>122</code>“, “<code>1222</code>“, “<code>12222</code>“,…<br>Regexp <code>/(12)+/</code> 表示字串 “<code>12</code>“, “<code>1212</code>“, “<code>121212</code>“, “<code>12121212</code>“….<br>上式中 <code>12</code> 以<code>( )</code>括住, 故 “<code>+</code>“ 所形容的是<code>12</code>, 重复出现的也是<code>12</code>.</p>
<p><code>|</code> 表示逻辑上的”<code>或</code>“(or)</p>
<p>例如:<br>Regexp <code>/Oranges?|apples?|water/</code> 可用以表示:  字串 “<code>Orange</code>“, “<code>Oranges</code>“ 或 “<code>apple</code>“, “<code>apples</code>“  或 “<code>water</code>“</p>
<h3 id="match是什么"><a href="#match是什么" class="headerlink" title="match是什么?"></a>match是什么?</h3><p>讨论 Regexp 时, 经常遇到 “某字串匹配( match )某 Regexp”的字眼. 其意思为: “这个 Regexp 可被解释成该字串”.</p>
<p>[例如]:<br>字串 “<code>the</code>“ 匹配(match) Regexp <code>/[Tt]he/</code>.<br>因为 Regexp <code>/[Tt]he/</code> 可解释成字串 “<code>the</code>“ 或 “<code>The</code>“, 故字串 “<code>the</code>“ 或 “<code>The</code>“ 都匹配(match) Regexp <code>/[Th]he/</code>.</p>
<h3 id="awk-中提供二个关系运算符-Relational-Operator-见注一"><a href="#awk-中提供二个关系运算符-Relational-Operator-见注一" class="headerlink" title="awk 中提供二个关系运算符(Relational Operator,见注一) ~ !~"></a>awk 中提供二个关系运算符(Relational Operator,见注一) <code>~</code> <code>!~</code></h3><p>它们也称之为 match, not match. 但函义与一般常称的 match 略有不同.</p>
<p>其定义如下:<br>A  表一字串, B 表一 Regular Expression<br>只要 A 字串中存在有子字串可 match (一般定义的 match) Regexp  B , 则 <code>A ~ B</code> 就算成立, 其值为 true, 反之则为 false.</p>
<p><code>!~</code> 的定义与<code>~</code>恰好相反.</p>
<p>例如:<br>“<code>another</code>“ 中含有子字串 “<code>the</code>“ 可 match Regexp <code>/[Tt]he/</code> , 所以<br><code>&quot;another&quot; ~ /[Tt]he/</code> 之值为 <code>true</code>.</p>
<p>[注一]: 有些论著不把这两个运算符( <code>~</code>, <code>!~</code>)与 Relational Operators 归为一类.</p>
<h3 id="应用-Regular-Expression-解题的简例"><a href="#应用-Regular-Expression-解题的简例" class="headerlink" title="应用 Regular Expression 解题的简例"></a>应用 Regular Expression 解题的简例</h3><p>下面列出一些应用 Regular Expression 的简例, 部分范例中会更改<code>$0</code>之值, 若您使用的 awk 不允许用户更改<code>$0</code>时, 请改用 gawk.</p>
<p>例1:<br>将文件中所有的字串 “Regular Expression” 或 “Regular expression” 换成 “Regexp”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123; gsub(/Regular[ \t]+[Ee]xpression/, "Regexp")</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>例2:<br>去除文件中的空白行(或仅含空白字符或tab的行)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'$0 !~ /^[ \t]*$/ &#123; print &#125;'</span> $*</div></pre></td></tr></table></figure></p>
<p>例3:<br>在文件中具有 <code>ddd-dddd</code> (电话号码型态,<code>d</code>表<code>digital</code>)的字串前加上”<code>TEL:</code>“<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123; gsub(/[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]/, "TEL: &amp;")</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>例4:<br>从文件的 Fullname 中分离出 路径 与 档名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN&#123;</div><div class="line">    Fullname = "/usr/local/bin/xdvi"</div><div class="line">    match(Fullname, /.*\//)</div><div class="line">    path = substr(Fullname, 1, RLENGTH-1)</div><div class="line">    name = substr(Fullname, RLENGTH+1)</div><div class="line">    print "path :", path, "  name :", name</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path : /usr/local/bin   name : xdvi</div></pre></td></tr></table></figure></p>
<p>例5:<br>将某一数值改以现金表示法表示(整数部分每三位加一撇,且含二位小数)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    Number = 123456789</div><div class="line">    Number = sprintf("$%.2f",Number)</div><div class="line">    while(match(Number, /[0-9][0-9][0-9][0-9]/))</div><div class="line">        sub(/[0-9][0-9][0-9][.,]/, ",&amp;", Number)</div><div class="line">    print Number</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$123,456,789.00</div></pre></td></tr></table></figure></p>
<p>例6:<br>把文件中所有具”<code>program数字.f</code>“形态的字串改为”<code>[Ref: program数字.c]</code>“<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    while(match($0, /program[0-9]+\.f/)) &#123;</div><div class="line">        Replace = "[Ref: "substr($0, RSTART, RLENGTH-2)".c]"</div><div class="line">        sub( /program[0-9]+\.f/, Replace)</div><div class="line">    &#125;</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sed 函数参数]]></title>
      <url>http://jarsonfang.github.io/etesting/sed-awk/sed-functions/</url>
      <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">fhc2007@fhc2007-desktop:~$ sed --help</div><div class="line">用法: sed [选项]... &#123;脚本(如果没有其他脚本)&#125; [输入文件]...</div><div class="line"></div><div class="line">  -n, --quiet, --silent</div><div class="line">                 取消自动打印模式空间</div><div class="line">  <span class="_">-e</span> 脚本, --expression=脚本</div><div class="line">                 添加“脚本”到程序的运行列表</div><div class="line">  <span class="_">-f</span> 脚本文件, --file=脚本文件</div><div class="line">                 添加“脚本文件”到程序的运行列表</div><div class="line">  -i[扩展名], --in-place[=扩展名]</div><div class="line">                 直接修改文件(如果指定扩展名就备份文件)</div><div class="line">  <span class="_">-l</span> N, --line-length=N</div><div class="line">                 指定“l”命令的换行期望长度</div><div class="line">  --posix</div><div class="line">                 关闭所有 GNU 扩展</div><div class="line">  -r, --regexp-extended</div><div class="line">                 在脚本中使用扩展正则表达式</div><div class="line">  <span class="_">-s</span>, --separate</div><div class="line">                 将输入文件视为各个独立的文件而不是一个长的连续输入</div><div class="line">  -u, --unbuffered</div><div class="line">                 从输入文件读取最少的数据，更频繁的刷新输出</div><div class="line">      --help     打印帮助并退出</div><div class="line">      --version  输出版本信息并退出</div></pre></td></tr></table></figure>
<p><span style="color:#ff0000">如果没有 -e, –expression, -f 或 –file 选项，那么第一个非选项参数被视为sed脚本。其他非选项参数被视为输入文件，如果没有输入文件，那么程序将从标准输入读取数据。</span></p>
<p><strong>注：-n 参数和 -i 参数不要一起使用。</strong></p>
<p>本章将以一节一个函数参数的方式 ,介绍所有 sed 提供的函数参数 , 其中有</p>
<p>|<a href="#s">s</a>|<a href="#d">d</a>|<a href="#a">a</a>|<a href="#i">i</a>|<a href="#c">c</a>|<a href="#p">p</a>|<a href="#l">l</a>|<a href="#r">r</a>|<a href="#w">w</a>|<a href="#y">y</a>|<a href="#!">!</a>|<a href="#n">n</a>|<a href="#q">q</a>|<a href="#equal">=</a>|<a href="#com">#</a>|<a href="#Next">N</a>|<a href="#Delete">D</a>|<a href="#Print">P</a>|<a href="#h">h</a>|<a href="#Hold">H</a>|<a href="#g">g</a>|<a href="#Gg">G</a>|<a href="#x">x</a>|<a href="#b">b</a>|<a href="#t">t</a>|</p>
<p>另外 , 在各节中 , 首先简单介绍函数参数功能 , 接着说明函数参数与位址参数配合的格式 ,而其中也一并描述 sed 执行此函数参数的工作情形。<br><a id="more"></a></p>
<h3 id="s"><a href="#s" class="headerlink" title="s"></a><a name="s">s</a></h3><p>函数参数 <code>s</code> 表示替换(substitute)文件内字串。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]s/pattern/replacemen/[flag]</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>s</code> 最多与两个位址参数配合。</li>
<li>关於 “<code>s/pattern/replacement/[flag]</code>“ 有下面几点说明:</li>
</ol>
<ul>
<li>pattern : 它为 reguler expression 字串。它表示文件中要被替换的字串。</li>
<li><p>replacement : 它为一般字串。但其内出现下列<span style="color:red">元字符</span>有特别意义 :</p>
<ul>
<li><p><code>&amp;</code> : 代表其前 pattern 字串。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/test/&amp; my car/'</span> 资料档名</div></pre></td></tr></table></figure>
<p>指令中 , <code>&amp;</code> 代表 pattern 字串 “<code>test</code>“。故执行後 , 资料档的 “<code>test</code>“ 被替换成 “<code>test my car</code>“。</p>
</li>
<li><p><code>n</code> : 代表 pattern 中被第 <code>n</code> (<code>n</code> 是从 1 到 9 的数字)个 <code>()</code> 所括起来的字串。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/(test) (my) (car)/[2 3 1]/'</span> 资料档名</div></pre></td></tr></table></figure>
<p>指令中 , <code>1</code> 表示 “<code>test</code>“、<code>2</code> 表示 “<code>my</code>“、<code>3</code> 表示 “<code>car</code>“ 字串。故执行後 , 资料档的 “<code>test my car</code>“被替换成 “<code>[my car test]</code>“。（注解：<code>()</code> 与 <code>1 ... 9</code> 合用）</p>
</li>
<li>\ : 可用它来还原一些特殊符号(如上述的 &amp; 和 \ )本身字面上的意义（<span style="color:red">转义</span>） , 或用它来<span style="color:red">代表换行</span>。</li>
</ul>
</li>
<li><p>flag : 主要用它来控制一些替换情况 :</p>
<ul>
<li>当 flag 为 <code>g</code> 时 , 代表替换所有符合(match)的字串 。</li>
<li>当 flag 为十进位数字 <code>m</code> 时 , 代表替换行内第 <code>m</code> 个符合的字串。</li>
<li>当 flag 为 <code>p</code> 时 , 代表替换第一个符合 pattern 的字串後 , 将资料输出标准输出档。</li>
<li>当 flag 为 <code>w wfile</code> 时 , 代表替换第一个符合 pattern 的字串後 , 输出到 <code>wfile</code> 档内(如果 <code>wfile</code> 不存在 , 则会重新开启名为 <code>wfile</code> 的档案)。</li>
<li>当没有 flag 时 , 则将资料行内第一个符合 pattern 的字串以 replacement 字串来替换 。</li>
</ul>
</li>
<li><p>delimiter : 在 “<code>/pattern/replace/[flag]</code>“ 中 “<code>/</code>“ 被当成 delimiter。除了空白(blank)、换行(newline) 之外 ,使用者可用任何字元作为 delimiter。例如下述编辑指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s<span class="comment">#/usr#/usr1#g</span></div></pre></td></tr></table></figure>
<p>上述命令中”<code>#</code>“为 delimiter。如果用 “<code>/</code>“ 做 delimiter , 则 sed 会将 pattern 与 replacement中的 “<code>/</code>“ 当成 delimiter 而发生错误。</p>
</li>
</ul>
<h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 替换 <code>input.dat</code> 档(後面如果没有特别指定 , 均假设文件档名为 <code>input.dat</code>)内 “<code>1996</code>“ 字串成 “<code>1997</code>“ , 同时将这些资料行存入 <code>year97.dat</code> 档内。</p>
<p><strong>说明:</strong> 用函数参数 <code>s</code> 指示 sed 将 “<code>1996</code>“ 字串替换成 “<code>1997</code>“ , 另外用 <code>s</code> argument 中的 flag <code>w</code> 指示 sed 将替换过的资料行存入 <code>year97.dat</code> 档内。</p>
<p><strong>sed 命令列:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/1996/1997/w year97.dat'</span> input.dat</div></pre></td></tr></table></figure></p>
<p>数字标志很少使用，在这种情况下，正则表达式在一行上重复匹配，而只需对其中某个位置的匹配进行替换。例如，某输入行也许包含 <code>[tab]</code>（制表符）输入，也许包含多个制表位。假设每行有3个制表符，并且要用“&gt;”替换第二个制表位，则可以使用下面的替换命令来完成该功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/[tab]/&gt;/2</div></pre></td></tr></table></figure></p>
<p>“<code>[tab]</code>“表示一个真正的制表符，而制表符在屏幕上是不可见的。如果输入是一行的文件，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Column1[tab]column2[tab]Column3[tab]Column4</div></pre></td></tr></table></figure></p>
<p>对这个文件运行以上脚本产生的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Column1[tab]column2&gt;Column3[tab]Column4</div></pre></td></tr></table></figure></p>
<p>注意，如果没有数字标志，则替换命令只替换第一个制表符（因此“<code>1</code>”可以被看作是默认的数字标志）。<br>我们可以对前面的示例做一些改动，用换行符取代每行上的第二个制表符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s/[tab]/</div><div class="line">/2</div></pre></td></tr></table></figure></p>
<p>注意，在反斜杠后面不允许有空格。这个脚本产生下面的结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Column1[tab]column2</div><div class="line">Column3[tab]Column4</div></pre></td></tr></table></figure></p>
<h3 id="d"><a href="#d" class="headerlink" title="d"></a><a name="d">d</a></h3><p>函数参数 d 表示删除资料行 , 其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]d</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>d</code> 最多与两个位址参数配合。</li>
<li><p>sed 执行删除动作情况如下 :</p>
<ol>
<li>将 pattern space 内符合位址参数的资料删除。</li>
<li>将下一笔资料读进 pattern space 。</li>
<li>重新执行 sed script。</li>
</ol>
</li>
</ol>
<p>补遗：删除命令是一个可以改变脚本中的控制流的命令。这是因为一旦执行这个命令，那么在“空的”模式空间（注：不允许在被删除的行上进行进一步操作）中就不会再有命令执行。所以，<span style="color:red">删除命令会导致读取新的输入行，而编辑脚本则从头开始新的一轮</span>。重要的是：如果某行匹配了模式中地址（地址参数），那么就删除整个行，而不只是删除行中匹配的部分（要删除行的一部分，可以使用替换命令并指定一个空的替换）。</p>
<h3 id="a"><a href="#a" class="headerlink" title="a"></a><a name="a">a</a></h3><p>函数参数 <code>a</code> 表示将资料添加到文件中。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]a 使用者所输入的资料</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>a</code> 最多与一个位址参数配合。</li>
<li>函数参数 <code>a</code> 紧接着 “\“ 字元用来表示此行结束 , 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在每行的结尾加入”<code>\n</code>“。</li>
<li>sed 执行添加动作情况如下: 当 pattern space 内资料输出後 , sed 跟着输出使用者所输入的资料。</li>
</ol>
<h4 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 添加 “<code>多工作业系统</code>“ 在含 “<code>UNIX</code>“ 字串的资料行後。假设 input.dat 档的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UNIX</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用函数参数 a 将所输入的资料添加在含 “UNIX” 字串的资料行後。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/UNIX/a\</div><div class="line">多工作业系统</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後, 其输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UNIX</div><div class="line">多工作业系统</div></pre></td></tr></table></figure></p>
<p>多行资料输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/UNIX/a\</div><div class="line">多工\n作业系统</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令后，其输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UNIX</div><div class="line">多工</div><div class="line">作业系统</div></pre></td></tr></table></figure></p>
<p>当然，上述命令也可以在一行中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/UNIX/a 多工\n作业系统&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>命令结果同上。</p>
<h3 id="i"><a href="#i" class="headerlink" title="i"></a><a name="i">i</a></h3><p>函数参数 <code>i</code> 表示将资料插入文件中。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]i 使用者所输入的资料</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>i</code> 最多与一个位址参数配合。</li>
<li>函数参数 <code>i</code> 紧接着 “\“ 字元用来表示此行结束, 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在每行的结尾加入”<code>\n</code>“。</li>
<li>sed 执行插入动作的情况如下: 在 pattern space 内资料输出前 , sed 先输出使用者所输入的资料。</li>
</ol>
<h4 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 “<code>文章版权属於中央研究院</code>“ 插在 <code>input.dat</code> 档中含 “<code>院长: 李远哲</code>“ 的资料行之前。假设 <code>input.dat</code> 档内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">院长: 李远哲</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用函数参数 <code>i</code> 将资料行 “<code>文章版权属於中央研究院</code>“ 插在含 “<code>院长: 李远哲</code>“ 的资料行之前。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/院长：李远哲/i\</div><div class="line">文章版权属於中央研究院</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後的输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">文章版权属於中央研究院</div><div class="line">院长: 李远哲</div></pre></td></tr></table></figure></p>
<h3 id="c"><a href="#c" class="headerlink" title="c"></a><a name="c">c</a></h3><p>函数参数 <code>c</code> 表示改变文件中的资料。其格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]c 使用者所输入的资料</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>c</code> 最多与两个位址参数配合。</li>
<li>函数参数 <code>c</code> 紧接着 “\“ 字元用来表示此行结束, 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在每行的结尾加入”\n”。</li>
<li>sed 执行改变动作的情况: 在 pattern space 内资料输出时, sed 改变它成为使用者所输入的资料。</li>
</ol>
<p>补遗：更改命令清除模式空间，它在空间模式中与删除命令有同样的效果。脚本中在更改命令之后的其他命令没有被提供。<br>插入命令和追加命令不影响模式空间的内容。提供的文本将不匹配脚本中后续命令中的任何地址，那些命令也不影响该文本。不管什么更改改变了模式空间，所提供的文本仍然会正确输出。当默认的输出受到抑制时也是这样——所提供的文本将被输出，即时模式空间不是那样的。而且，所提供的文本不影响 sed 的内部行计数器。</p>
<h3 id="p"><a href="#p" class="headerlink" title="p"></a><a name="p">p</a></h3><p>函数参数 p 表示印出模式空间中的资料。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]p</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>p</code> 最多与两个位址参数配合。</li>
<li>sed 执行印出动作的情况如下: sed 拷备一份 pattern space 内容至标准输出档。</li>
</ol>
<p>除非抑制（<code>-n</code>）默认的输出，否则打印命令将输出行的重复复制。当抑制默认的输出或者当通过程序的流程控制来避免到达脚本的底部时，可能会使用它。</p>
<h3 id="l"><a href="#l" class="headerlink" title="l"></a><a name="l">l</a></h3><p>函数参数 <code>l</code> , 除可将模式空间资料中的 nonprinting character（非打印字符） 显示为两个数字的ASCII 代码（GNU sed 显示某些字符，例如，回车符，使用的是 ANSI C 转义序列，而不是八进制。）外 , 其於均与函数参数 <code>p</code> 相同。例如 , 将下面 input.dat 档中的 <code>^[</code> 以 ASCII 码印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The Great ^[ is a movie starring Steve McQueen.</div></pre></td></tr></table></figure></p>
<p>（在 vi 中的插入模式下通过键入 CTRL-V（大小写无关），然后按下 ESC 键，产生字符 ^[ ，类似的，按下回车键可产生字符 ^M，按下 CTRL-A（大小写无关），产生字符 ^A，其余类推。）</p>
<p>执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;l&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>後, 则输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The Great 33 is a movie starring Steve McQueen.</div><div class="line">The Great     is a movie starring Steve McQueen.</div></pre></td></tr></table></figure></p>
<p>上述第二行资料为 sed 的自动输出。</p>
<p>（在 sed 中不能用 ASCII 值匹配字符（也不能匹配八进制数值），所以，使用 sed 替换（或删除）文档中的非打印字符，得用 vi 来编辑 sed 的编辑命令脚本，使用命令脚本来执行 sed 而无法在命令行上输入 sed 的命令参数。）</p>
<h3 id="r"><a href="#r" class="headerlink" title="r"></a><a name="r">r</a></h3><p>函数参数 <code>r</code> 表示读入文件的内容到模式空间。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]r file</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>r</code> 最多与一个位址参数配合。</li>
<li>在指令中, 函数参数 <code>r</code> 与文件名称间, 必须有一空格（空格后到换行符前的每个字符都被当做文件名，因此，前导的和嵌入的空格也是文件名的一部分）。</li>
<li>sed 执行读入动作的情况如下: 在 pattern space 内资料输出後, sed 读入由 file 指定的文件的内容跟着输出。当 file 不存在时, sed 照样执行其它指令而不会有任何错误讯息产生。</li>
</ol>
<h3 id="w"><a href="#w" class="headerlink" title="w"></a><a name="w">w</a></h3><p>函数参数 <code>w</code> 表示将模式空间的内容写入文件。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]w file</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>w</code> 最多与两个位址参数配合。</li>
<li>在指令中, 函数参数 <code>w</code> 与文件名称间 , 必须有一空格（空格后到换行符前的每个字符都被当做文件名，因此，前导的和嵌入的空格也是文件名的一部分）。</li>
<li>sed 执行写出动作的情况如 : 将 pattern space 内资料写入文件 file。资料写入时 , 会取代(overwrite)原来文件内的资料（如果一个脚本中有多个指令写到同一个文件中，那么每个写命令都将内容追加到这个文件中）。另外, 当文件不存在时, sed 会重新产生(creat)它。</li>
</ol>
<h3 id="y"><a href="#y" class="headerlink" title="y"></a><a name="y">y</a></h3><p>函数参数 <code>y</code> 表示转换资料中的字元。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]y /xyz.../abc.../</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明 :</p>
<ol>
<li>函数参数最多配合两个位址参数。</li>
<li>指令中, <code>/abc.../xyz.../</code>(x、y、z、a、b、c 代表某些字元) 为 <code>y</code> 的 argument 。其中 <code>abc...</code> 与 <code>xyz...</code> 的字元个数必须相同。</li>
<li>sed 执行转换时, 将 pattern space 内资料内的 <code>a</code> 字元转换成 <code>x</code> 字元 、<code>b</code> 字元转换成 <code>y</code> 字元 、<code>c</code> 字元转换成 <code>z</code> 字元 …。</li>
</ol>
<h4 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 <code>input.dat</code> 档中的小写字母改成大写。假设 <code>input.dat</code> 档的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Sodd&apos;s Second Law:</div><div class="line">        Sooner or later, the worst possible set of</div><div class="line">        circumstances is bound to occur.</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 利用函数参数 <code>y</code> 指示 sed 做字母大小的转换。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;</div><div class="line">y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令输出结果如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SODD&apos;S SECOND LAW:</div><div class="line">      SOONER OR LATER, THE WORST POSSIBLE SET OF</div><div class="line">      CIRCUMSTANCES IS BOUND TO OCCUR.</div></pre></td></tr></table></figure></p>
<h3 id=""><a href="#" class="headerlink" title="!"></a><a name="!">!</a></h3><p>函数参数 <code>!</code> 表示不执行函数参数。当有如下指令时 ,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]! 函数参数</div></pre></td></tr></table></figure></p>
<p>表示, 对符合位址参数之资料不执行函数参数。例如删除 , 除了含有 “regular” 字串的资料行外，所有资料行, 则执行 <code>!</code> 后的删除命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/regular/!d&apos; input.dat</div></pre></td></tr></table></figure></p>
<h3 id="n"><a href="#n" class="headerlink" title="n"></a><a name="n">n</a></h3><p>函数参数 <code>n</code> 表示读入下一行资料。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]n</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>n</code> 最多配合两个位址参数。</li>
<li><p>sed 执行读入下一行动作的情况如下 :</p>
<ol>
<li>输出在 pattern space 的资料（默认输出）。</li>
<li>将下一笔资料读到 pattern space。</li>
<li>执行<span style="color:red">下一个</span>编辑指令(不用返回到脚本的顶端)。</li>
</ol>
</li>
</ol>
<p>补遗：<code>next</code> 命令改变了正常的流控制（正常情况下，直到到达脚本的底部才会输出模式空间的内容，总是在读入新行之后从脚本的顶端开始）。实际上，<code>next</code> 命令导致输入的下一行取代模式空间中的当前行。脚本中的后续命令应用于替换后的行，而不是当前行。<span style="color:red">如果没有抑制默认输出，那么在替换发生之前会打印当前行</span>。在较长的脚本中，必须记住<span style="color:red">出现在 next 命令之前的命令不会应用于新的输入行，而出现在其后面的命令不应用于旧的输入行</span>。</p>
<h4 id="范例-4"><a href="#范例-4" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 输出 <code>input.dat</code> 档内偶数行资料。假设 <code>input.dat</code> 档内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The</div><div class="line">UNIX</div><div class="line">Operation</div><div class="line">System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 在命令列上</p>
<ul>
<li>以选项 <code>-n</code> , 将资料输出的控制权转给指令。</li>
<li>利用函数参数 <code>n</code> 将下一行资料(偶数行)取代 pattern space 内的资料行(奇数行)。</li>
<li>利用函数参数 <code>p</code> 将 pattern space 内的资料(偶数行)输出。<br>最後 , 整个输出只有原先档内的偶数行资料。</li>
</ul>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n -e &apos;n&apos; -e &apos;p&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後, 输出的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UNIX</div><div class="line">System</div></pre></td></tr></table></figure></p>
<h3 id="q"><a href="#q" class="headerlink" title="q"></a><a name="q">q</a></h3><p>函数参数 <code>q</code> 表示跳离 sed 。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]q</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>q</code> 最多配合一个位址参数。</li>
<li>sed 执行跳离动作时 , 它停止读取新的输入行（并停止将它们发送到输出）。</li>
</ol>
<p>（退出命令 <code>q</code> 只适用于单行的地址。一旦找到和 address 匹配的行，那么脚本就结束。注：需要小心的是，在将编辑操作写回到原始文件的任何程序中不要使用 <code>q</code> 命令。在执行 <code>q</code> 命令之后，就不会再产生输出。在想要编辑文件的一部分并保留剩余部分不改变的情况下，不要使用 <code>q</code> 命令。这种情况下使用 <code>q</code> 时初学者常犯的非常危险的错误。）</p>
<p>示例，下面一行命令使用退出命令从文件中打印前100行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;100q&apos; test</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>它打印每一行，直到它到达行100并且退出。在这点上，这个命令的功能与 UNIX 的 <code>head</code> 命令类似。<br><code>quit</code> 的另一个可能的用法是从文件中提取了想要的内容后退出脚本。</p>
<h4 id="范例-5"><a href="#范例-5" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong>  对文件档执行 <code>script_file</code> 内的编辑指令 , 除非遇到 “<code>Linux</code>“ 字串。</p>
<p><strong>说明:</strong>  无论 <code>script_file</code> 内是何种指令 , 使用者只要在命令列上用指令<code>/Linux/q</code> , 函数参数 <code>q</code> 会强迫 sed 遇到 “<code>Linux</code>“ 时做跳离动作。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/Linux/q&apos; -f script_file input.dat</div></pre></td></tr></table></figure></p>
<h3 id="-1"><a href="#-1" class="headerlink" title="="></a><a name="equal">=</a></h3><p>函数参数 <code>=</code> 表示印出资料的行号。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]=</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>=</code> 最多配合两个位址参数。</li>
<li>执行时, 行号将在资料输出前先输出。</li>
</ol>
<h4 id="范例-6"><a href="#范例-6" class="headerlink" title="范例:"></a>范例:</h4><p><strong>题目:</strong> 印出 <code>input.dat</code> 档内资料行数。假设 <code>input.dat</code> 的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The UNIX</div><div class="line">Operating System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用函数参数 <code>=</code> 来印出资料的行数。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;=&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後 , 输出的结果如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">The UNIX</div><div class="line">2</div><div class="line">Operating System</div></pre></td></tr></table></figure></p>
<h3 id="-2"><a href="#-2" class="headerlink" title="#"></a><a name="com">#</a></h3><p><span style="color:red">在 script file 内 , 函数参数 <code>#</code> 後的文字为注解。当注解文字超过多行时 , 其行间须以 “\n” 换行字元相隔</span>。在 sed 的System V版本中，注释只允许出现在第一行。而 GNU sed 则可以在脚本的任何地方放置注释，甚至是跟在命令行的后面。注释行的第一个字符必须是“#”号。<span style="color:red">如果跟在<code>#</code>后面的下一个字符是<code>n</code>，那么脚本不会自动产生输出。这和指定命令行选项 <code>-n</code> 是等价的。跟在 <code>n</code> 后面的其余内容被看做是注释。在POSIX标准中，采用这种方式的 <code>#n</code> 必须是文件的前两个字符</span>。</p>
<p>到此为止，前面介绍的命令（函数参数）可归类为基本的 sed 命令，下面将要介绍的这些命令可归类为 sed 的高级命令。sed 的高级命令可分成3个组：</p>
<ol>
<li>处理多行模式空间（<code>N</code>、<code>D</code>、<code>P</code>）。</li>
<li>采用保持空间来保存模式空间的内容并使它可用于后续的命令（<code>H</code>、<code>h</code>、<code>G</code>、<code>g</code>、<code>x</code>）。</li>
<li>编写使用分支和条件指令的脚本来更改控制流（<code>:</code>、<code>b</code>、<code>t</code>）。</li>
</ol>
<h3 id="多行模式空间"><a href="#多行模式空间" class="headerlink" title="多行模式空间"></a>多行模式空间</h3><p>在前面的正则表达式讨论中，我们强调模式匹配是面向行的。像 grep 这样的程序尝试在单个输入行上匹配一个模式。这就使它很难匹配一个在一行的结尾处开始，并在下一行的开始处结束的短语。其他一些模式只有当在多行上匹配才有意义。<br>sed 能查看模式空间的多个行。这就允许匹配模式扩展到多行上。下面我们将要介绍创建多行模式空间并处理它的内容的命令。这里的 3 个多行命令（<code>N</code>、<code>D</code>、<code>P</code>）对应于前面介绍的小写字母的基本命令（<code>n</code>、<code>d</code>、<code>p</code>）。</p>
<h3 id="N"><a href="#N" class="headerlink" title="N"></a><a name="Next">N</a></h3><p>函数参数 <code>N</code> 表示添加下一笔资料在 pattern space 内。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]N</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>N</code> 最多配合两个位址参数。</li>
<li>sed 执行时, 将下一行资料读入并添加在 pattern space 内, 资料行间以换行字元(embedded newline character)分隔。此外 , 在替换时 , 换行字元可用转义序列 <code>\n</code> 来匹配。</li>
</ol>
<p><span style="color:red">在多行模式空间中，元字符“<code>^</code>”匹配模式空间中的第一个字符，而不匹配换行符后面的字符。同样，“<code>$</code>”只匹配模式空间中最后的换行符，而不匹配任何嵌入的换行符。</span>在执行 <code>Next</code> 命令之后，控制将被传递给脚本中的后续命令（同 <code>next</code> ）。<code>Next</code> 命令与 <code>next</code> 命令不同，<code>next</code> 输出模式空间的内容，然后读取新的输入行。<code>next</code> 命令不创建多行模式空间。</p>
<h4 id="范例-7"><a href="#范例-7" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将下述两行资料合。假设 <code>input.dat</code> 的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The UNIX</div><div class="line">Operating System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 先利用函数参数 <code>N</code> 将两行资料置於 pattern space 内 , 在利用函数参数 <code>s/\n/ /</code> 将两行资料间的分隔符 <code>\n</code> 以空白替代 , 如此两行资料变成一行输出。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;N&apos; -e &apos;s/\n/ /&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後 , 其输出的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The UNIX Operating System</div></pre></td></tr></table></figure></p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a><a name="Delete">D</a></h3><p>函数参数 <code>D</code> 表示删除 pattern space 内的第一行资料（删除模式空间中直到第一个嵌入的换行符的这部分内容）。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]D</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>D</code> 最多配合两个位址参数。</li>
<li>函数参数 <code>D</code> 与 <code>d</code> 的比较如下 :</li>
</ol>
<ul>
<li>当 pattern space 内只有一资料行时 , <code>D</code> 与 <code>d</code> 作用相同。</li>
<li><p>当 pattern space 内有多行资料行时</p>
<ul>
<li><code>D</code> 表示只删除 pattern space 内第一行资料 ; <code>d</code> 则全删除。</li>
<li><code>D</code> 表示执行删除后 , pattern space 内不添加下一笔资料 , 而将剩下的资料重新执行 sed script （返回到脚本的顶端，将这些指令应用于模式空间剩余的内容）; <code>d</code> 则读入下一行后重新执行 sed script（返回到脚本的顶端）。</li>
</ul>
</li>
</ul>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a><a name="Print">P</a></h3><p>函数参数 <code>P</code> 表示印出 pattern space 内的第一行资料（输出多行模式空间的第一部分，直到第一个嵌入的换行符为止）。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]P</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>P</code> 最多配合两个位址参数。</li>
<li><code>P</code> 与 <code>p</code> , 除了面对的 pattern space 内的资料行数不同外 , 其它均相同。</li>
</ol>
<p><span style="color:red">在执行完脚本的最后一个命令之后，模式空间的内容自动输出（<code>-n</code> 选项或 <code>#n</code> 抑制这个默认的动作）</span>。因此当默认的输出被抑制或者脚本中的控制流更改，以至不能达到脚本的底部时，需要使用打印命令（<code>P</code> 或 <code>p</code>）。<code>Print</code> 命令经常出现在 <code>Next</code> 命令之后和 <code>Delete</code> 命令之前。这 3 个命令能建立一个输入/输出循环，用来维护两行的模式空间，但是一次只输出一行。这个循环的目的是只输出模式空间的第一行，然后<span style="color:red">返回到脚本的顶端</span>将所有的命令应用于模式空间的第二行。没有这个循环，当执行脚本中的最后一个命令时，模式空间中的这两行都被输出。</p>
<h4 id="范例-8"><a href="#范例-8" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 输出 <code>input.dat</code> 档内奇数行资料。假设 <code>input.dat</code> 档内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The</div><div class="line">UNIX</div><div class="line">System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 在命令列上</p>
<ul>
<li>以选项 <code>-n</code>, 将资料输出的控制权转给指令。</li>
<li>利用函数参数 <code>N</code> 将偶数行添加至 pattern space 内奇数行後。</li>
<li>利用函数参数 <code>P</code> 将 pattern space 内的第一行(奇数行)输出。</li>
</ul>
<p>在奇数行输出後 , pattern space 内剩下的资料行(偶数行)则被放弃输出。最後 , 整个输出只有原先的奇数行资料。</p>
<p><strong>sed 命令列:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n -e &apos;N&apos; -e &apos;P&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後, 输出的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The</div><div class="line">System</div></pre></td></tr></table></figure></p>
<h3 id="模式空间与保持空间"><a href="#模式空间与保持空间" class="headerlink" title="模式空间与保持空间"></a>模式空间与保持空间</h3><p>模式空间的内容可以<span style="color:red">复制</span>到保持空间，而且保持空间的内容也可以<span style="color:red">复制</span>到模式空间。有一组命令用于在保持空间和模式空间之间移动数据。保持空间用于临时存储。单独的命令不能寻址保持空间或者更改它的内容。</p>
<p>保持空间最常见的用途是，当改变模式空间中的原始内容时，用于保留当前输入行的<span style="color:red">副本</span>。影响模式空间的命令有：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>缩写</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hold</td>
<td>h 或 H</td>
<td>将模式空间的内容复制或追加到保持空间</td>
</tr>
<tr>
<td>Get</td>
<td>g 或 G</td>
<td>将保持空间的内容复制或追加到模式空间</td>
</tr>
<tr>
<td>Exchang</td>
<td>x</td>
<td>交换模式空间和保持空间的内容</td>
</tr>
</tbody>
</table>
<p>hold(<code>h</code>，<code>H</code>)命令将数据移至保持空间，而 get(<code>g</code>，<code>G</code>)命令将保持空间的数据移回到模式空间。同一命令的小写字母和大写字母之间的差别是，小写字母命令改写目的缓存区的内容，而大写字母命令追加缓存区的现有内容。</p>
<p>hold（小写）命令用模式空间的内容取代保持空间的内容。get（小写）命令用保持空间的内容取代模式空间的内容。<br>Hold（大写）命令在保持空间的内容之后放置一个换行符，且后面跟随模式空间的内容（即使保持空间是空的，换行符也被追加到保持空间）。Get（大写）命令在模式空间的内容之后放置一个换行符，且后面跟随保持空间的内容。</p>
<p>交换命令交换两个缓存区的内容。对两个缓存区没有副作用。</p>
<h3 id="h"><a href="#h" class="headerlink" title="h"></a><a name="h">h</a></h3><p>函数参数 <code>h</code> 表示暂存 pattern space 的资料至 hold space。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]h</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>h</code> 最多配合两个位址参数。</li>
<li>sed 执行暂存动作时 , 会盖掉(overwrite) hold space 内原来的资料。</li>
<li>当 sed 全部执行结束时 , hold space 内资料会自动清除。</li>
</ol>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a><a name="Hold">H</a></h3><p>函数参数 <code>H</code> 与 <code>h</code> 唯一差别是 , sed 执行 <code>h</code> 时 , 资料盖掉(overwrite) hold space 内原来的资料 ,而 <code>H</code> , 资料则是 “添加(append)” 在 hold space 原来资料後。</p>
<h3 id="g"><a href="#g" class="headerlink" title="g"></a><a name="g">g</a></h3><p>函数参数 <code>g</code> 表示与函数参数 <code>h</code> 相反的动作 , 它表示将 hold space 内资料放回 pattern space内。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]g</div></pre></td></tr></table></figure></p>
<p>函数参数 g 最多配合两个位址参数。<br>sed 执行放回动作时 , 资料盖掉(overwrite) pattern space 内原来的资料。</p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a><a name="Gg">G</a></h3><p>函数参数 <code>G</code> 与 <code>g</code> 唯一差别是 , sed 执行 <code>g</code> 时 , 资料盖掉(overwrite) pattern space 内原来的资料 , 而 <code>G</code> , 资料则是 “添加(append)” 在 pattern space 原来资料後。</p>
<h3 id="x"><a href="#x" class="headerlink" title="x"></a><a name="x">x</a></h3><p>函数参数 <code>x</code> 表示交换 hold space 与 pattern space 内的资料。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]x</div></pre></td></tr></table></figure></p>
<p>函数参数 <code>x</code> 大部份与其它处理 hold space 的函数参数一起配合。例如 , 将 <code>input.dat</code> 档内第 1 行资料取代第 3 行资料。此时 , 用函数参数 <code>h</code> 与 <code>x</code> 来配合。其中 , 以函数参数 <code>h</code> 将第 1 资料存入 hold space ;当第 3 行资料出现在pattern space , 以函数参数 <code>x</code> 交换 hold space 与 pattern space 的内容。如此 , 第 3 行资料就被第 1 资料替代。其命令列如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;1h&apos; -e &apos;3x&apos; input.dat</div></pre></td></tr></table></figure></p>
<h3 id="高级流程控制指令"><a href="#高级流程控制指令" class="headerlink" title="高级流程控制指令"></a>高级流程控制指令</h3><p>分支（<code>b</code>）和测试（<code>t</code>）命令将脚本中的控制转移到包含特殊标签的行。如果没有指定标签，则将控制转移到脚本的结尾处。分支命令用于无条件转移，测试命令用于有条件转移，它们只有当替换命令改变当前行时才会执行。<br>标签是任意不多于7个字符的序列（GNU sed 允许标签为任意长度）。标签本身占据一行并以冒号开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:mylabel</div></pre></td></tr></table></figure></p>
<p>在冒号和标签之间不允许有空格。行结尾处的空格将被认为是标签的一部分。当在分支命令或测试命令中指定标签时，在命令和标签之间允许有空格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b mylabel</div></pre></td></tr></table></figure></p>
<p>注意，不要在标签后面插入空格。</p>
<h3 id="b-label"><a href="#b-label" class="headerlink" title="b :label"></a><a name="b">b :label</a></h3><p>函数参数 <code>:</code> 与函数参数 <code>b</code> 可在 sed script 内建立类似 BASIC 语言中 GOTO 指令的功能。其中 , 函数参数 <code>:</code> 建立标记;函数参数 <code>b</code> 将下一个执行的指令 branch 到标记处执行。函数参数 <code>:</code> 与 <code>b</code> , 在 script file 内配合的情况如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">编辑指令m1</div><div class="line">:记号</div><div class="line">编辑指令m2</div><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">[address1[, address2]]b [记号]</div></pre></td></tr></table></figure></p>
<p>其中, 当 sed 执行至指令<code>[address1[, address2]]b [记号]</code>时 , 如 pattern space 内的资料符合位址参数 , 则 sed 将下一个执行的位置 branch 至由 <code>:记号</code>设定的标记处 , 也就是再由 “<code>编辑指令 m2</code>“ … 执行。另外 , 如果指令中函数参数 <code>b</code> 後没有记号 , 则 sed 将下一个执行的指令 branch 到 script file 的最後 , 利用此可使 sed script 内有类似 C 语言中的 case statement 结构。</p>
<h4 id="范例-9"><a href="#范例-9" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 <code>input.dat</code> 档内资料行的开头字母重覆印 40 次。假设 <code>input.dat</code> 档的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">B</div><div class="line">C</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用指令 <code>b p1</code> 与 <code>:p1</code> 构成执行增加字母的回圈(loop) , 同时在字母出现 40 个时 , 也用指令 <code>b</code> 来跳出圈。下面就以档内第一行资料 “<code>A</code>“ 为例 , 描述它如何连续多添加 39 个 “<code>A</code>“ 在同一行:</p>
<ul>
<li>用指令 <code>s/A/AA/</code> 将 “<code>A</code>“ 替换成 “<code>AA</code>“。</li>
<li>用指令 <code>b p1</code> 与 <code>:p1</code> 构成回圈(loop) , 它目的使上述动作被反覆的执行。每执行一次圈 , 则资料行上的 “<code>A</code>“ 就多出一个。例如 , 第一次圈资料行变成 “<code>AA</code>“ , 第二次圈资料行变成 “<code>AAA</code>“ …。</li>
<li>用指令 <code>[ABC]\{40\}/b</code> （注解：<code>\{重复次数\}</code> 、<code>\{下限,上限\}</code>）来作为停止回圈的条件。当资料行有连续 40 个 <code>A</code> 出现时 , 函数参数 <code>b</code> 将执行的指令跳到最後 , 停止对此行的编辑。</li>
</ul>
<p>同样, 对其它资料行也如同上述的方式执行。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;&#123;</div><div class="line">:p1</div><div class="line">/A/s/A/AA/</div><div class="line">/B/s/B/BB/</div><div class="line">/C/s/C/CC/</div><div class="line">/[ABC]\&#123;40\&#125;/b</div><div class="line">b p1</div><div class="line">&#125;&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>命令结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</div><div class="line">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</div><div class="line">CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</div></pre></td></tr></table></figure></p>
<h3 id="t"><a href="#t" class="headerlink" title="t"></a><a name="t">t</a></h3><p>基本上, 函数参数 <code>t</code> 与 函数参数 <code>b</code> 的功能类似 , 除了在执行 <code>t</code> 的 branch 前 , 会先去测试其前的替换指令有没有执行替换成功外。在 script file 内的情况如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">编辑指令m1</div><div class="line">:记号</div><div class="line">编辑指令m2</div><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">s/.../.../</div><div class="line">[address1[, address2]]t [记号]</div><div class="line">编辑指令m3</div></pre></td></tr></table></figure></p>
<p>其中 , 与函数参数 <code>b</code> 不同处在於, 执行函数参数 <code>t</code> branch 时, 会先检查其前一个替换指令成功与否。如成功, 则执行 branch; 不成功, 则不 branch, 而继续执行下一个编辑指令, 例如上面的<code>编辑指令m3</code>。</p>
<h4 id="范例-10"><a href="#范例-10" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 <code>input.dat</code> 档中资料 <code>A1</code> 替换成<code>C1</code>、<code>C1</code> 替换成<code>B1</code>、<code>B1</code> 替换成<code>A1</code>。<code>input.dat</code> 档的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">代号</div><div class="line">B1</div><div class="line">A1</div><div class="line">B1</div><div class="line">C1</div><div class="line">A1</div><div class="line">C1</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> <code>input.dat</code> 档中全部资料行只需要执行一次替换动作 , 但为避免资料被替换多次 , 所以利用函数参数 <code>t</code> 在 sed script 内形成一类似 C 语言中 case statement 结构 , 使每行资料替换一次後能立即用函数参数 <code>t</code> 跳离替换编辑。</p>
<p><strong>sed 命令列:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;&#123;</div><div class="line">s/A1/C1/</div><div class="line">t</div><div class="line">s/C1/B1/</div><div class="line">t</div><div class="line">s/B1/A1/</div><div class="line">t</div><div class="line">&#125;&apos; input.dat</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sed 学习手册]]></title>
      <url>http://jarsonfang.github.io/etesting/sed-awk/sed-manual/</url>
      <content type="html"><![CDATA[<h2 id="sed-简要介绍"><a href="#sed-简要介绍" class="headerlink" title="sed 简要介绍"></a>sed 简要介绍</h2><p>Sed(Stream EDitor)为 UNIX 系统上提供将编辑工作自动化的编辑器 , 使用者无需直接编辑资料。使用者可利用 sed 所提供 20 多种不同的<span style="color:red;">函数[参数] </span>, 组合它们完成不同的编辑动作。此外 ,由於 sed 都以行为单位编辑文件 , 故其亦是行编辑器(line editor)。<br> 一般 sed 最常用在编辑那些需要不断重覆某些编辑动作的文件上, 例如将文件中的某个字串替换成另一个字串等等。这些相较於一般 UNIX 编辑器(交互式的, 如 vi、emacs)用手动的方式修改文件, sed 用起来较省力。</p>
<p>sed 是一个非交互式上下文(context)编辑器,它被设计在下列三种情况下发挥作用:</p>
<ol>
<li>编辑那些对舒适的交互式编辑而言太大的文件。</li>
<li>在编辑命令太复杂而难于在交互模式下键入的时候，编辑任何大小的文件。</li>
<li>要在对输入的一趟扫描中有效的进行多个”全局”(global)编辑函数。</li>
</ol>
<p>因为每次只把输入的某些行驻留在内存中, 并且不使用临时文件,所以可编辑的文件的有效大小,只受限于输入和输出要同时共存于次级存储的要求。可以单独的建立复杂的编辑脚本并作为给 sed 的命令文件。对于复杂的编辑,这节省了可观的键入和随之而来的错误。从命令文件运行 sed 高效于作者所知道的任何交互式编辑器,甚至包括能用预先写好的脚本驱动的编辑器。</p>
<p>相较于交互式编辑器而言,根本性的损失是缺乏相对地址(由于操作是每次一行的),和缺乏对命令如期运行的立即验证。<br><a id="more"></a></p>
<h2 id="sed-如何工作"><a href="#sed-如何工作" class="headerlink" title="sed 如何工作"></a>sed 如何工作</h2><p>如同其它 UNIX 命令, sed 由标准输入读入编辑文件并由标准输出送出结果。下图表示 sed将资料行 “<code>Unix</code>“ 替换成 “<code>UNIX</code>“,<br><img src="/uploads/images/sed.gif" alt="sed"><br>在图中, 上方 standard input 为标准输入, 是读取资料之处; standard output 为标准输出, 是送出结果之处;中间 sed 方块的下面两个虚线方块表示 sed 的工作流程。其中, 左边虚线方块表示 sed 将标准输入资料置入pattern space, 右边虚线方块表示 sed 将 pattern space 中编辑完毕後的资料送到标准输出。</p>
<p>在虚线方块中, 两个实线方块分别表示 pattern space 与 sed script。其中, pattern space 为一缓区, 它是sed 工作场所; 而 sed script 则表示一组执行的编辑指令。</p>
<p>在图中, 左边虚线方块 “Unix” 由标准输入置入 pattern space; 接着 , 在右边虚线方块中, sed执行 sed script 中的编辑指令<code>s/Unix/UNIX/</code>, 结果 “Unix” 被替换成 “UNIX”, 之後, “UNIX” 由pattern space 送到标准输出。</p>
<p>总合上述所言, 当 sed 由标准输入读入一行资料并放入 pattern space 时, sed 依照 sed script 的编辑指令逐一对 pattern space 内的资料执行编辑, 之後, 再由 pattern space 内的结果送到标准输出, 接着再将下一行资料读入。如此重复执行上述动作 , 直至读完所有资料行为止。</p>
<p>sed 维护一种模式空间（patter space），即一个工作区或临时缓冲区，当应用编辑命令时将在那里存储单个输入行。sed 还维护了称为保持空间(hold space)的另一个临时缓冲区，可以将模式空间的内容复制到保持空间并在以后检索它们。</p>
<h2 id="使用-sed"><a href="#使用-sed" class="headerlink" title="使用 sed"></a>使用 sed</h2><p>sed 命令列可分成编辑指令与文件档部份。其中, 编辑指令负责控制所有的编辑工作; 文件档表示所处理的档案。sed 的编辑指令均由<span style="color:#ff0000">位址(address)</span>与<span style="color:#ff0000">函数(function)</span>两部份组成, 其中, 在执行时, sed 利用它的<span style="color:red;">位址参数</span>来决定编辑的对象; 而用它的<span style="color:red;">函数[参数]</span>编辑。</p>
<p>此外, sed 编辑指令, 除了可在命令列上执行, 也可在档案内执行。其中差别只是在命令列上执行时, 其前必须加上选项 <code>-e</code>; 而在档案内时, 则只需在其档名前加上选项 <code>-f</code>。另外, sed 执行编辑指令是依照它们在命令列上或档内的次序。</p>
<p>下面各节, 将介绍执行命令列上的编辑指令、sed 编辑指令、执行档案内的编辑指令、执行多个档案的编辑、及执行 sed 输出控制。</p>
<h3 id="执行命令列上的编辑指令"><a href="#执行命令列上的编辑指令" class="headerlink" title="执行命令列上的编辑指令"></a>执行命令列上的编辑指令</h3><p>当编辑指令在命令列上执行时, 其前必须加上选项 <code>-e</code> 。其命令格式如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'编辑指令 1'</span> <span class="_">-e</span> <span class="string">'编辑指令 2'</span> ... 文件档</div></pre></td></tr></table></figure></p>
<p>其中, 所有编辑指令都紧接在选项 <code>-e</code> 之後, 并置於两个 “<code>&#39;</code>“ 特殊字元间。另外, 命令上编辑指令的执行是由左而右。</p>
<p>一般编辑指令不多时, 使用者通常直接在命令上执行它们。例如, 删除 <code>yel.dat</code> 内 <code>1</code> 至<code>10</code> 行资料 , 并将其馀文字中的 “<code>yellow</code>“ 字串改成 “<code>black</code>“ 字串。此时 , 可将编辑指令直接在命令上执行 , 其命令如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'1,10d'</span> <span class="_">-e</span> <span class="string">'s/yellow/black/g'</span> yel.dat</div></pre></td></tr></table></figure></p>
<p>在命令中 , 编辑指令 ‘<code>1,10d</code>‘ 执行删除 <code>1</code> 至 <code>10</code> 行资料 ; 编辑指令 ‘<code>s/yellow/black/g</code>‘，”<code>yellow</code>“ 字串替换(substitute)成 “<code>black</code>“ 字串。</p>
<h3 id="sed-的编辑指令"><a href="#sed-的编辑指令" class="headerlink" title="sed 的编辑指令"></a>sed 的编辑指令</h3><p> sed 编辑指令的格式如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[,address2]]<span class="keyword">function</span>[argument]</div></pre></td></tr></table></figure></p>
<p>其中 , 位址参数 <code>address1</code> 、<code>address2</code> 为行数或 regular expression 字串 , 表示所执行编辑的资料行 ; 函数参数 <code>function[argument]</code> 为 sed 的内定函数 , 表示执行的编辑动作。</p>
<p>下面两小节 , 将仔细介绍位址参数的表示法与有哪些函数参数供选择。</p>
<p><strong>位址(address)参数的表示法</strong></p>
<p>实际上 , 位址参数表示法只是将要编辑的资料行 , 用它们的行数或其中的字串来代替表示它们。下面举几个例子说明(指令都以函数参数 d 为例) :</p>
<ul>
<li>删除档内第 10 行资料 , 则指令为 <code>10d</code></li>
<li>删除含有 “man” 字串的资料行时 , 则指令为 <code>/man/d</code></li>
<li>删除档内第 10 行到第 200 行资料, 则指令为 <code>10,200d</code></li>
<li>删除档内第 10 行到含 “man” 字串的资料行 , 则指令为 <code>10,/man/d</code></li>
</ul>
<p>接下来 , 以位址参数的内容与其个数两点 , 完整说明指令中位址参数的表示法(同样也以函数参数 <code>d</code> 为例)。</p>
<ul>
<li><p>位址参数的内容:</p>
<ul>
<li>位址为十进位数字 （行地址）: 此数字表示行号。当指令执行时 , 将对符合此行号的资料执行函数参数指示的编辑动作。例如 ,删除资料档中的第 15 行资料 , 则指令为 <code>15d</code>。其馀类推 ,如删除资料档中的第 m 行资料 , 则指令为 <code>md</code> 。行号是由 sed 维护的内部行数。该计数器不会因为多个输入文件而重置。因此，不管指定多少个输入文件，在<span style="color:red">输入流</span>（多个文件（流）构成一个输入流，文件个数不同，输入流的大小也会不同）中也只有一行<code>1</code>。同样，输入流也只有一个最后的行。可以使用寻址符号 <code>$</code> 指定。下面的示例删除输入流的最后一行：<code>$d</code>（<code>$</code> 符号不应该和正则表达式中使用的 <code>$</code> 相混淆，在这里表示行的结束）</li>
<li>位址为 regular expression（模式地址）: 当资料行中有符合 regular expression 所表示的字串时 , 则执行函数参数指示的编辑动作。另外 ,在regular expression 前後必须加上 “<code>/</code>“。例如指令为 <code>/t.*t/d</code> , 表示删除所有含两 “<code>t</code>“ 字母的资料行。其中 , “<code>.</code>“表示任意字元; “<code>*</code>“ 表示其前字元可重复任意次 , 它们结合 “<code>.*</code>“ 表示两 “<code>t</code>“ 字母间的任意字串。</li>
</ul>
</li>
<li><p>位址参数的个数 : 在指令中 , <span style="color:red">如果没有指定位址参数</span> , 表示全部资料行执行函数参数所指示的编辑动作;<span style="color:red"> 如果只有一位址参数</span> , 表示只有符合位址的资料行才编辑 ; <span style="color:red">如果指定了由逗号分隔的两个位址参数 </span>, 如 <code>address1,address2</code> 时 ,表示对资料区执行编辑 , <code>address1</code> 代表起始资料行 , <code>address2</code> 代表结束资料行（即编辑命令应用于第一个地址的第一行和它后面的行，直到匹配第二个地址的行（包括此行）。你可以把第一个地址看做是启用动作，并把第二个地址看做是禁用动作。sed 没有办法先行决定第二个地址是否会匹配。一旦匹配了第一个地址，这个（些）动作就将应用于这些行。于是编辑命令应用于“所有”随后的行直到第二个地址被匹配。）。<span style="color:red">如果地址后面跟有感叹号(!)</span>，那么编辑命令就应用于<span style="color:red">不匹配</span>该地址的所有的行。对於上述内容 , 以下面例子做具体说明。</p>
<ol>
<li>例如指令为<code>d</code>其表示删除档内所有资料行。</li>
<li>例如指令为<code>5d</code>其表示删除档内第五行资料。</li>
<li>例如指令为<code>1,/apple/d</code>其表示删除资料区 , 由档内第一行至内有 “<code>apple</code>“ 字串的资料行。</li>
<li>例如指令为<code>/apple/,/orange/d</code>其表示删除资料区 , 由档内含有 “<code>apple</code>“ 字串至含有 “<code>orange</code>“ 字串的资料行</li>
<li>例如指令为<code>/regular/!d</code>其表示删除所有的不包含“<code>regular</code>”字符串的资料行。</li>
</ol>
</li>
</ul>
<p><strong>有哪些函数(function)参数</strong></p>
<p>下表中介绍所有 sed 的函数参数的功能。</p>
<table>
<thead>
<tr>
<th>函数参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:label</td>
<td>建立script file内指令互相参考的位置</td>
</tr>
<tr>
<td>#</td>
<td>建立注解</td>
</tr>
<tr>
<td>{ }</td>
<td>集合有相同位址参数的指令</td>
</tr>
<tr>
<td>!</td>
<td>不执行函数参数</td>
</tr>
<tr>
<td>=</td>
<td>印出资料行数（line number）</td>
</tr>
<tr>
<td>a\</td>
<td>添加使用者输入的资料</td>
</tr>
<tr>
<td>b label</td>
<td>将执行的指令跳至由 : 建立的参考位置</td>
</tr>
<tr>
<td>c\</td>
<td>以使用者输入的资料取代资料</td>
</tr>
<tr>
<td>d</td>
<td>删除资料</td>
</tr>
<tr>
<td>D</td>
<td>删除 pattern space 内第一个 newline 字母 \n 前的资料</td>
</tr>
<tr>
<td>g</td>
<td>从 hold space 中拷贝资料</td>
</tr>
<tr>
<td>G</td>
<td>拷贝 hold space 中的资料添加到 pattern space</td>
</tr>
<tr>
<td>h</td>
<td>从 pattern space 中拷贝资料到 hold space</td>
</tr>
<tr>
<td>H</td>
<td>拷贝 pattern space 中的资料添加到 hold space</td>
</tr>
<tr>
<td>I</td>
<td>印出资料中的 nonprinting character 的ASCII码值</td>
</tr>
<tr>
<td>i\</td>
<td>插入添加使用者输入的资料行</td>
</tr>
<tr>
<td>n</td>
<td>读入下一笔资料</td>
</tr>
<tr>
<td>N</td>
<td>添加下一笔资料到 pattern space</td>
</tr>
<tr>
<td>p</td>
<td>印出资料</td>
</tr>
<tr>
<td>P</td>
<td>印出 pattern space 内第一个 newline 字母 \n 前的资料</td>
</tr>
<tr>
<td>q</td>
<td>跳出 sed 编辑</td>
</tr>
<tr>
<td>r</td>
<td>读入文档内容</td>
</tr>
<tr>
<td>s</td>
<td>替换字串</td>
</tr>
<tr>
<td>t label</td>
<td>先执行一替换编辑命令，如果替换成功，则将编辑指令跳至 :label 处执行</td>
</tr>
<tr>
<td>w</td>
<td>写资料到文档</td>
</tr>
<tr>
<td>x</td>
<td>交换 hold space 与 pattern space 中的内容</td>
</tr>
<tr>
<td>y</td>
<td>转换(transform)字元</td>
</tr>
</tbody>
</table>
<p>虽然 , sed 只有上表所述几个拥有基本编辑功能的函数 , 但由指令中位址参数和指令与指令间的配合 , 也能使sed 完成大部份的编辑任务。</p>
<h3 id="执行档案内的编辑指令"><a href="#执行档案内的编辑指令" class="headerlink" title="执行档案内的编辑指令"></a>执行档案内的编辑指令</h3><p>当执行的指令太多 , 在命令列上撰写起来十分混乱 , 此时 , 可将这些指令整理储存在档案  (譬如档名为 <code>script_file</code> )内 , 用选项 <code>-f script_file</code> , 则让 sed 执行 <code>script_file</code> 内的编辑指令。其命令的格示如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> script_file 文件档</div></pre></td></tr></table></figure></p>
<p>其中 , 执行 <code>script_file</code> 内编辑指令的顺序是由上而下。例如上一节的例子 , 其可改成如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> ysb.scr yel.dat</div></pre></td></tr></table></figure></p>
<p>其中 , <code>ysb.scr</code> 档的内容如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1,10d</div><div class="line">s/yellow/black/g</div></pre></td></tr></table></figure></p>
<p>另外 , 在命令列上可混合使用选项 <code>-e</code> 与 <code>-f</code> , sed 执行指令顺序依然是由命令列的左到右,如执行至 <code>-f</code> 後档案内的指令 , 则由上而下执行。</p>
<h3 id="执行多个文件档的编辑"><a href="#执行多个文件档的编辑" class="headerlink" title="执行多个文件档的编辑"></a>执行多个文件档的编辑</h3><p>在 sed 命令列上 , 一次可执行编辑多个文件档 , 它们跟在编辑指令之後。例如 , 替换 <code>white.dat</code>、<code>red.dat</code>、<code>black.dat</code> 档内的 “<code>yellow</code>“ 字串成 “<code>blue</code>“ , 其命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/yellow/blue/g'</span> white.dat red.dat black.dat</div></pre></td></tr></table></figure></p>
<p>上述命令执行时 , sed 依 <code>white.dat</code>、<code>red.dat</code>、<code>black.dat</code> 顺序 , 执行编辑指令 <code>s/yellow/blue/</code> ,进行字串的替换。</p>
<h3 id="执行输出的控制"><a href="#执行输出的控制" class="headerlink" title="执行输出的控制"></a>执行输出的控制</h3><p>在命令列上的选项 <code>-n</code> 表示输出由编辑指令控制。由前章内容得知 , sed 会 “自动的”将资料由 pattern space 输送到标准输出档。但藉着选项 <code>-n</code> , 可将 sed 这 “自动的” 的动作改成 “被动的” 由它所执行的编辑指令来决定结果是否输出。</p>
<p>由上述可知 , 选项 <code>-n</code> 必须与编辑指令一起配合 , 否则无法获得结果。例如 , 印出<code>white.dat</code>档内含有 “<code>white</code>“ 字串的资料行 , 其命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="_">-e</span> <span class="string">'/white/p'</span> white.dat</div></pre></td></tr></table></figure></p>
<p>上面命令中 , 选项 <code>-n</code> 与编辑指令 <code>/white/p</code>  一起配合控制输出。其中 ，选项 <code>-n</code> 将输出控制权移给编辑指令；<code>/white/p</code> 将资料行中含有 “<code>white</code>“ 字串印出萤幕。</p>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>一般在实际使用编辑器的过程中 , 常需要执行替换文件中的字串、搬移、删除、与搜寻资料行等等动作。当然 , 一般交谈式编辑器(如 vi、emacs)都能做得到上述功能 , 但文件一旦有大量上述编辑需求时 , 则用它们编辑十分没有效率。本章将用举例的方式说明如何用 sed 自动执行这些编辑功能。此外 , 在本章范例中 , 均以下述方式描述文件的需求 :</p>
<blockquote>
<p>将文件中…资料 , 执行…(动作)</p>
</blockquote>
<p>如此 , 目的是为了能将它们迅速的转成编辑指令。其中 , “<code>...资料</code>“ 部份 , 转成指令中的<code>位址参数</code>表示 ;”<code>执行...动作</code>“ 部份 , 则转成<code>函数参数</code>表示 。另外 ,将一个地址嵌套在另一个地址中（内层地址必须在外层地址的作用范围之内），或者 “执行…动作” 要由数个函数参数表示时, 则可利用 “<code>{</code>“与 “<code>}</code>“ 集合这些函数参数（注：左大括号必须在行末，而且右大括号本身必须单独占一行。要确保在大括号之后没有空格。）, 其指令形式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">位址参数&#123;</div><div class="line">   函数参数 1</div><div class="line">   函数参数 2</div><div class="line">   函数参数 3</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述指令表示 , 将对符合位址参数的资料 , 依次执行函数参数 1、函数参数 2、函数参数 3 … 表示的动作。</p>
<p>下面各节 , 分别举例说明 sed 替换资料、移动、删除资料、及搜寻资料的命令。</p>
<h3 id="替换文件中的资料"><a href="#替换文件中的资料" class="headerlink" title="替换文件中的资料"></a>替换文件中的资料</h3><p>sed 可替换文件中的字串、资料行、甚至资料区。其中 , 表示替换字串的指令中的函数参数为 <code>s</code> ;表示替换资料行、或资料区的指令中的函数参数为 <code>c</code> 。上述情况以下面三个例子说明。</p>
<p>例一. 将文件中含 “<code>machine</code>“ 字串的资料行中的 “<code>phi</code>“ 字串 , 替换成为 “<code>beta</code>“ 字串。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/machine/s/phi/beta/g'</span> input.dat (以後文件档都以 input.dat 代表)</div></pre></td></tr></table></figure></p>
<p>例二. 将文件中第 5 行资料 , 替换成句子 “Those who in quarrels interpose, must often wipe a bloody nose.”。其命令列如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'5c</span></div><div class="line">Those must often wipe a bloody nose.</div><div class="line">' input.dat</div></pre></td></tr></table></figure></p>
<p>例三. 将文件中 1 至 100 行的资料区 , 替换成如下两行资料 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">How are you?</div><div class="line">data be deleted!</div></pre></td></tr></table></figure></p>
<p>则其命令列如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'1,100c</span></div><div class="line">How are you?</div><div class="line">data be deleted!</div><div class="line">' input.dat</div></pre></td></tr></table></figure></p>
<h3 id="搬动文件中的资料"><a href="#搬动文件中的资料" class="headerlink" title="搬动文件中的资料"></a>搬动文件中的资料</h3><p>使用者可用 sed 中的 hold space 暂存编辑中的资料、用函数参数 <code>w</code> 将文件资料搬动到它档内储存、或用函数参数 <code>r</code> 将它档内容搬到文件内。Hold space 是 sed 用来暂存 pattern space 内资料的暂存器 , 当 sed 执行函数参数<code>h</code>、<code>H</code> 时 , 会将 pattern space 资料暂存到 hold space ;当执行函数参数<code>x</code>、<code>g</code>、<code>G</code> 时 , 会将暂存的资料取到 pattern space 。下面举三个例子说明。</p>
<p>例一. 将文件中的前 100 资料 , 搬到文件中第 300 後输出。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> mov.scr 文件档</div></pre></td></tr></table></figure></p>
<p>mov.scr 档的内容为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1,100&#123;</div><div class="line">H</div><div class="line">d</div><div class="line">&#125;</div><div class="line">300G</div></pre></td></tr></table></figure></p>
<p>其中 ,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1,100&#123;</div><div class="line">H</div><div class="line">d</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它表示将文件中的前 100 资料 , 先储存在 hold space 之後删除 ;指令 <code>300G</code> 表示 , 将 hold space 内的资料 , 添加在文件中的第 300 行资料後输出。</p>
<p>例二. 将文件中含 “<code>phi</code>“ 字串的资料行 , 搬至 <code>mach.inf</code> 档中储存。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/phi/w mach.inf'</span> 文件档</div></pre></td></tr></table></figure></p>
<p>例三. 将 <code>mach.inf</code> 档内容 , 搬至文件中含 “<code>beta</code>“ 字串的资料行。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/beta/r mach.inf'</span> 文件档</div></pre></td></tr></table></figure></p>
<p>另外 , 由於 sed 是一 stream 编辑器 , 故理论上输出後的文件资料不可能再搬回来编辑。</p>
<h3 id="删除文件中的资料"><a href="#删除文件中的资料" class="headerlink" title="删除文件中的资料"></a>删除文件中的资料</h3><p>因为 sed 是一行编辑器 , 所以 sed 很容易删除个别资料行或整个资料区。一般用函数参数 <code>d</code> 或 <code>D</code> 来表示。下面举两个例子说明。</p>
<ul>
<li><p>将文件内所有空白行全部删除。其命令列为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/^$/d'</span> 文件档</div></pre></td></tr></table></figure>
<p>regular expression <code>^$</code> 表示空白行。 其中 , <code>^</code> 限制其後字串必须在行首; <code>$</code> 限制其前字串必须在行尾。</p>
</li>
<li><p>将文件内连续的空白行 , 删除它们成为一行。其命令列为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/^$/&#123;</span></div><div class="line">N</div><div class="line">/^$/D</div><div class="line">&#125;' 文件档</div></pre></td></tr></table></figure>
<p>其中 , 函数参数 <code>N</code> 表示 , 将空白行的下一行资料添加至 pattern space 内。函数参数 <code>/^$/D</code> 表示 ,当添加的是空白行时 , 删除第一行空白行 , 而且剩下的空白行则再重新执行指令一次。指令重新执行一次 , 删除一行空白行 ,如此反覆直至空白行後添加的为非空白行为止 , 故连续的空白行最後只剩一空白行被输出。</p>
</li>
</ul>
<h3 id="搜寻文件中的资料"><a href="#搜寻文件中的资料" class="headerlink" title="搜寻文件中的资料"></a>搜寻文件中的资料</h3><p>sed 可以执行类似 UNIX 命令 grep 的功能。理论上 , 可用 regular expression 。例如 , 将文件中含有 “<code>gamma</code>“ 字串的资料行输出。则其命令列如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="_">-e</span> <span class="string">'/gamma/p'</span> 文件档</div></pre></td></tr></table></figure></p>
<p>但是 , sed 是行编辑器 , 它的搜寻基本上是以一行为单位。因此 , 当一些字串因换行而被拆成两部份时 , 一般的方法则不可行。此时 , 就必须以合两行的方式来搜寻这些资料。其情况如下面例子:</p>
<p>例. 将文件中含 “<code>omega</code>“ 字串的资料输出。其命令列如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> gp.scr 文件档</div></pre></td></tr></table></figure></p>
<p><code>gp.scr</code> 档的内容如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/omega/b</div><div class="line">N</div><div class="line">h</div><div class="line">s/.*n//</div><div class="line">/omega/b</div><div class="line">g</div><div class="line">D</div></pre></td></tr></table></figure></p>
<p>在上述 sed script , 因藉着函数参数 <code>b</code> 形成类似 C 语言中的 case statement 结构 , 使得 sed 可分别处理当资料内含 “<code>omega</code>“ 字串 ; 当 “<code>omega</code>“ 字串被拆成两行 ; 以及资料内没有”<code>omega</code>“ 字串的情况。接下来就依上述的三种情况 , 将 sed script 分成下面三部份来讨论。</p>
<ol>
<li><p>当资料内含 “<code>omega</code>“ , 则执行编辑指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/omega/b</div></pre></td></tr></table></figure>
<p>它表示当资料内含 “<code>omega</code>“ 字串时 , sed 不用再对它执行後面的指令 , 而直接将它输出。</p>
</li>
<li><p>当资料内没有”<code>omega</code>“ , 则执行编辑指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">N</div><div class="line">h</div><div class="line">s/.*n//</div><div class="line">/omega/b</div></pre></td></tr></table></figure>
<p>其中 , 函数参数 <code>N</code> , 它表示将下一行资料读入使得 pattern space 内含前後两行资料 。函数参数 <code>h</code> , 它表示将 pattern space 内的前後两行资料存入 hold space 。函数参数 <code>s/.*n//</code> , 它表示将 pattern space 内的前後两行资料合成一行。<code>/omega/b</code> , 它表示如果合後的资料内含 “<code>omega</code>“ 字串 , 则不用再执行它之後的指令 , 而将此资料自动输出 。</p>
</li>
<li><p>当合并後的资料依旧不含 “<code>omega</code>“ , 则执行编辑指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g</div><div class="line">D</div></pre></td></tr></table></figure>
<p>其中 , 函数参数 <code>g</code> , 它表示将 hold space 内合前的两行资料放回 pattern space。 函数参数 <code>D</code> , 它表示删除两行资料中的第一行资料 , 并让剩下的那行资料 , 重新执行 sed script 。如此 ,无论是资料行内或行间的字串才可搜寻完全。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sed & awk 概述]]></title>
      <url>http://jarsonfang.github.io/etesting/sed-awk/sed-awk-overview/</url>
      <content type="html"><![CDATA[<p>摘自《sed与awk》 Dale Dougberty&amp;Arnold Robbins 著</p>
<p>如果你正要开始学习 sed 与 awk，最好从了解它们的共同点入手：</p>
<ul>
<li>它们都使用相似的语法来调用。</li>
<li>它们都是面向字符流的，都是从文本文件中<span style="color:red">一次一行</span>的读取输入,并将输出直接送到标准输出端。</li>
<li>它们都使用正则表达式进行模式匹配。</li>
<li>它们允许用户在脚本中指定指令。</li>
</ul>
<p>它们有如此多的共同点，原因之一是它们都起源于相同的行编辑器—— ed。下面首先对 ed 做简短介绍，再介绍 sed 和 awk 是如何一步步形成<span style="color:red">可编程的编辑器</span>的。sed 和 awk 的区别在于它们控制所做的工作时所用的指令不同。这是一个主要的区别，而且这影响了这些程序最适于处理的任务类型。<br><a id="more"></a></p>
<h2 id="awk-起源于-sed-和-grep-而不是-ed"><a href="#awk-起源于-sed-和-grep-而不是-ed" class="headerlink" title="awk 起源于 sed 和 grep 而不是 ed"></a>awk 起源于 sed 和 grep 而不是 ed</h2><p>可以将 awk 的起源追溯到 sed 和 grep，并且经由这两个程序追溯到 ed（最初的UNIX行编辑器）。</p>
<p>如果使用过行编辑器，那么理解 sed 和 awk 的行定位就会更容易。如果使用过 vi（全屏幕的编辑器），那么你一定熟悉由底层的行编辑器 ex（它依次是 ed 中的特征的扩展集）衍生的大量命令。</p>
<p>下面来看一些使用行编辑器 ed 的基本操作。不要担心，这只是帮助你了解 sed 和 awk 的练习，而不是想让你相信行编辑器的奇妙。这个练习中出现的 ed 命令和稍后要学的 sed 命令相同。你可以自由地使用 ed 做实验，以便对它如何工作有一个了解。</p>
<p>使用行编辑器，每次可以处理一行。知道处于文件中的哪一行是很重要的。当使用 ed 打开文件时，它显示了文件中的字符个数并定位在<span style="color:red">最后一行</span>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ed <span class="built_in">test</span></div><div class="line">339</div></pre></td></tr></table></figure></p>
<p>没有提示符。如果输入了 ed 不理解的命令，它将打印一个问号作为错误消息。可以输入打印命令 p 来显示当前的行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p</div><div class="line">label on the first box.</div></pre></td></tr></table></figure></p>
<p>默认情况下，一个命令只影响当前的行。要进行一项编辑工作，首先要移至想要编辑的行，然后应用相应的命令。要移到某一行，就要指定它的地址（address）。一个地址可以由一个行号、一个指示文件中特定位置的符号或一个正则表达式组成。通过输入行号 1 可以转到第一行，然后输入删除命令来删除那一行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">You might think of a regular expression</div><div class="line">d</div></pre></td></tr></table></figure></p>
<p>输入“<code>1</code>”使第一行成为当前行，并在屏幕上显示它。ed 中的删除命令是<code>d</code>，上例中是删除当前行。与移至某行然后再对它进行编辑不同的是，可以将标识命令对象的某一行或某些行的地址，放在编辑命令的前面作为命令的前缀。例如，如果输入“<code>1d</code>”，那么第一行就被删除。</p>
<p>还可以将一个正则表达式作为一个地址。为了删除包含单词“<code>regular</code>”的行，可以使用下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/regular/d</div></pre></td></tr></table></figure></p>
<p>其中的斜杠界定的对象是正则表达式，“<code>regular</code>”是想要匹配的字符串。这个命令删除包含“<code>regular</code>”的第一行并且使跟在它后面的这一行成为当前行。<br><span style="color:red">注：确信(be sure)你已经理解了使用删除命令来删除整个行。它不只是删除那一行上的单词“<code>regular</code>”。</span><br>要删除包含这个正则表达式的所有行，可以在命令前面加上字母<code>g</code>，表示该命令是一个全局命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/d</div></pre></td></tr></table></figure></p>
<p>全局命令使匹配正则表达式的所有行成为特定命令的对象。</p>
<p>迄今为止只是使用了删除文本的命令，替代文本（用文中的一部分取代另一部分）更为有趣。ed 中的替换命令 <code>s</code> 是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address]s/pattern/replacement/flag</div></pre></td></tr></table></figure></p>
<p><code>pattern</code> 是一个正则表达式，并用 <code>replacement</code> 替代当前行中与这个正则表达式匹配的字符串。例如，下面的命令用“<code>complex</code>”取代当前行上第一次出现的“<code>regular</code>”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/regular/complex/</div></pre></td></tr></table></figure></p>
<p>由于没有指定地址，所以它只影响当前行上的<span style="color:red">第一次出现</span>。如果当前行上没有找到“<code>regular</code>”则出现一个错误。为了寻找同一行上的多次出现，必须指定 <code>g</code> 作为标志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>这个命令改变了当前行上的所有的出现。必须指定地址从而使该命令不只是对当前行操作。下面的替换命令指定了一个地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/regular/s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>这个命令影响文件中与这个地址匹配的<span style="color:red">第一行</span>。记住，第一个“<code>regular</code>”是一个地址，第二个是匹配替换命令的模式。要将它应用于所有的行，必须使用全局命令，即在地址前放置<code>g</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>现在，这个替换应用于所有的地方，即所有行上的所有出现。<br><span style="color:red">注：注意“<code>g</code>”的不同含义。开始处的“<code>g</code>”是全局命令，意味着对所有与地址匹配的行进行改变。结尾处的“<code>g</code>”是一个标志，意味着改变一行上的每个出现，不只是第一个。</span></p>
<p><span style="color:red">地址和模式不必相同。</span>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular expression/s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>表示在包含字符串“<code>regular expression</code>”的任意行上，用“<code>complex</code>”代替“<code>regular</code>”。<br><span style="color:red">如果地址和模式相同，那么可以通过指定两个连续的定界符（<code>//</code>）来告诉 ed。</span><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/s//complex/g</div></pre></td></tr></table></figure></p>
<p>在这个例子中，“<code>regular</code>”被指定为“地址”，同时应用相应的地址匹配替换模式。</p>
<p>PS：到此为止，也不难理解 vi 中的“搜索及替换”命令了。</p>
<p><span style="color:red">vi 编辑器中的“搜索及替换”命令：</span></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/pattern</code></td>
<td>从光标开始处向文件尾搜索pattern</td>
</tr>
<tr>
<td><code>?pattern</code></td>
<td>从光标开始处向文件首搜索pattern</td>
</tr>
<tr>
<td><code>n</code></td>
<td>在同一方向重复上一次搜索命令</td>
</tr>
<tr>
<td><code>N</code></td>
<td>在反方向上重复上一次搜索命令</td>
</tr>
<tr>
<td><code>:s/p1/p2/g</code></td>
<td>将当前行中所有p1均用p2替换<br>（如果去掉结尾处的“g”标志，则只是替换当前行中p1的第一次出现）</td>
</tr>
<tr>
<td><code>:n1,n2 s/p1/p2/g</code></td>
<td>将第n1至n2行中所有p1均用p2替换<br>（如果去掉结尾处的“g”标志，则只是替换匹配的每一行中p1的第一次出现）</td>
</tr>
<tr>
<td><code>:g/p1/s//p2/g</code></td>
<td>将文件中所有p1均用p2替换</td>
</tr>
</tbody>
</table>
<p><span style="color:red">类似的 UNIX 实用工具 grep 来源于 ed 中的下面的全局命令：</span><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/re/p</div></pre></td></tr></table></figure></p>
<p>（PS：估计这也是程序名称“grep”的由来吧）</p>
<p>它表示“<code>全局正则表达式打印</code>”。grep 是从 ed 中提取并可用做外部程序的行编辑命令。它是执行一个编辑命令的“硬连接（hard-wired）”。将正则表达式作为命令行上的一个参数并将它用做要打印的行的地址。如下例所示，寻找匹配“<code>box</code>”的行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ grep <span class="string">'box'</span> <span class="built_in">test</span></div><div class="line">You are given a series of boxes,the first one labeled <span class="string">"A"</span>,</div><div class="line">label on the first box.</div></pre></td></tr></table></figure></p>
<p>它打印匹配正则表达式的所有的行。</p>
<p>注：在使用正则表达式作为命令行上的一个参数时，假如模式中包含有可以由 shell 解释的空格或任意字符（例如<code>$</code>和<code>*</code>），那么必须用<strong>单引号</strong>括住。这也是在命令行上使用正则表达式时的一个良好习惯——正则表达式要正确地传递到使用它的程序而不只是由 shell 解释。</p>
<p>ed 的一个更有趣的特征是脚本化编辑工作的能力，将编辑命令放在独立的文件中并将它们作为行编辑器的输入。例如，如果将一系列命令放到名为 <code>ed-script</code> 的文件中，下面的命令将执行这个脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ed <span class="built_in">test</span> &lt; ed-script</div></pre></td></tr></table></figure></p>
<p>这个特征使 ed 成为可编程的编辑器。也就是说，你可以脚本化任何手动执行的操作。</p>
<h2 id="ed、sed、awk"><a href="#ed、sed、awk" class="headerlink" title="ed、sed、awk"></a>ed、sed、awk</h2><p>sed 是作为特殊目的的编辑器而创建的，用于专门执行脚本；与 ed 不同，它不能交互地使用。sed 与 ed 的主要区别在于它是面向字符流的。<span style="color:red">默认情况下，到 sed 的所有输入都会经过相应的处理，并转为标准输出。输入文件本身不发生改变。如果确实想改变输入文件，一般使用 shell 机制进行输出重定向（注：不要将来自命令的输出重定向到输入文件，否则会改写输入文件。甚至可能在 sed 处理这个文件之前发生，并破坏你的数据。），当你对所做的编辑工作满意时，用修改后的版本代替最初的文件。 </span></p>
<p>ed 不是面向字符流的，并且文件本身会发生改变。ed 脚本必须包含保存文件并退出编辑器的命令。它不产生到达屏幕的输出，但由特殊命令生成的东西除外。</p>
<p>sed 的字符流定位对如何应用寻址有重要的影响。在 ed 中没有指定地址的命令只影响当前行。sed 遍历文件，每次一行，这样每一行都成为当前行，而且每一行都应用这个命令。结果是 sed 对文件中的每一行应用了没有地址的命令。</p>
<p>看一下下面的替换命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/regular/complex/</div></pre></td></tr></table></figure></p>
<p>如果在 ed 中交互式的输入这个命令，则用“<code>complex</code>”取代当前行上第一次出现的“<code>regular</code>”。在 ed 脚本中，如果这是脚本中的第一个命令，那么它就只是应用于文件的最后一行（ed 的默认当前行）。然而，在 sed 脚本中，相同的命令应用于所有的行。也就是说，sed 命令是隐式的全局命令。在 sed 中，上一个示例的命令和 ed 中如下所示的全局命令结果相同。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/s//complex/</div></pre></td></tr></table></figure></p>
<p><span style="color:red">注：理解 ed 中的当前行寻址与 sed 中全局行寻址之间的区别是很重要的。在 ed 中，使用寻址扩大受命令影响的行数；在 sed 中，使用寻址限制受命令影响的行数。</span></p>
<p>awk 是作为可编程的编辑器而开发的，同 sed 一样，它也是面向字符流的，并且解释编辑命令的脚本。awk 与 sed 不同的地方是它废弃了行编辑器的命令集。它提供了仿效 C 语言的程序设计语言，例如，<code>print</code> 语句取代 <code>p</code> 命令；但延续了寻址的概念，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/regular/ &#123;<span class="built_in">print</span>&#125;</div></pre></td></tr></table></figure></p>
<p>用于打印匹配“<code>regular</code>”的那些行。大括号（<code>{}</code>）用于包围应用于同一个地址的一个或多个语句。</p>
<p>在脚本中使用程序设计语言的优点是，它提供了更多的方式来控制可编程的编辑器所做的事情。awk 提供了表达式、条件语句、循环和其他程序设计结构。</p>
<p>awk 最独特的特征之一是它分析或拆分每个输入行，并生成可用于脚本处理的独立的单词（一个编辑器，例如 vi，也识别单词，允许一个单词一个单词的移动，或者使一个单词成为操作对象，但是这些特征只能在交互式下使用）。虽然 awk 是作为可编程的编辑器设计的，但它还可以完成许多其他任务。</p>
<p>更多的关于 sed &amp; awk ，请详读《sed &amp; awk》 Dale Dougberty &amp; Arnold Robbins 著</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开发者日常使用的 Git 命令]]></title>
      <url>http://jarsonfang.github.io/etesting/VCS/everyday-git/</url>
      <content type="html"><![CDATA[<p>原文链接： <a href="https://www.kernel.org/pub/software/scm/git/docs/everyday.html" target="_blank" rel="external">Everyday GIT With 20 Commands Or So</a>   翻译： <a href="http://blog.jobbole.com" target="_blank" rel="external"> 伯乐在线 </a> - <a href="http://blog.jobbole.com/author/cjpan/" target="_blank" rel="external">cjpan</a><br>译文链接： <a href="http://blog.jobbole.com/54184/" target="_blank" rel="external">http://blog.jobbole.com/54184/</a> （下文在原译文基础上有修正补充）</p>
<p><span style="color:red;">原文（英）最后更新时间：Last updated 2013-02-15 15:53:17 UTC</span></p>
<p>这些命令分四种类型：①不需要和其他开发者协作的独立开发者，会经常用到 <code>git init</code>、<code>git show branch</code>、<code>git commit</code> 等命令；②需要和其他人协作的开发者，会常用到 <code>git clone</code>、<code>git push</code>、<code>git pull</code>、<code>git format patch</code>；③在项目中负责接收其他开发者发来更新的核心开发者，会常用到 <code>git am</code>、<code>git pull</code>、<code>git format patch</code>、<code>git revert</code>、<code>git push</code>；④ 代码仓库管理员常用 <code>git daemon</code>、<code>git shell</code> ……</p>
<p>对于任何想做提交的人来说，甚至对于某位单独工作的人来说，【个人开发者（单独开发）】部分命令都是必不可少的。如果你和别人一起工作，你也会需要【个人开发者（参与者）】部分列出的命令。</p>
<p>除了上述的部分，担当【集成人员】角色的人需要知道更多命令。【代码库管理】命令帮助系统管理员负责管理，以及向git代码库提交内容。<br><a id="more"></a></p>
<h2 id="个人开发者（单独开发）Individual-Developer-Standalone"><a href="#个人开发者（单独开发）Individual-Developer-Standalone" class="headerlink" title="个人开发者（单独开发）Individual Developer (Standalone)"></a>个人开发者（单独开发）Individual Developer (Standalone)</h2><p>单独的个人开发者不会与他人交换修补程序，只用到下列命令，独自在单独的代码库上工作：</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-init.html" target="_blank" rel="external">git-init(1)</a> 创建新代码库。to create a new repository.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-show-branch.html" target="_blank" rel="external">git-show-branch(1)</a> 查看你在哪里。to see where you are.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-log.html" target="_blank" rel="external">git-log(1)</a> 查看发生过什么。to see what happened.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-checkout.html" target="_blank" rel="external">git-checkout(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-branch.html" target="_blank" rel="external">git-branch(1)</a> 切换分支。to switch branches.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-add.html" target="_blank" rel="external">git-add(1)</a> 管理索引文件。to manage the index file.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-diff.html" target="_blank" rel="external">git-diff(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-status.html" target="_blank" rel="external">git-status(1)</a> 查看你正在做什么。to see what you are in the middle of doing.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-commit.html" target="_blank" rel="external">git-commit(1)</a> 将推进当前分支。to advance the current branch.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-reset.html" target="_blank" rel="external">git-reset(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-checkout.html" target="_blank" rel="external">git-checkout(1)</a> （带路径名参数）放弃（撤销）修改。to undo changes.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-merge.html" target="_blank" rel="external">git-merge(1)</a> 合并本地分支。to merge between local branches.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-rebase.html" target="_blank" rel="external">git-rebase(1)</a> 维护主题分支。to maintain topic branches.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-tag.html" target="_blank" rel="external">git-tag(1)</a> 给已知点打标签。to mark known point.</li>
</ul>
<h3 id="实例-Examples"><a href="#实例-Examples" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>用Tar包作为一个新代码库的起始点</strong><br>Use a tarball as a starting point for a new repository.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ tar zxf frotz.tar.gz</div><div class="line">$ <span class="built_in">cd</span> frotz</div><div class="line">$ git init</div><div class="line">$ git add . &lt;1&gt;</div><div class="line">$ git commit -m <span class="string">"import of frotz source tree."</span></div><div class="line">$ git tag v2.43 &lt;2&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>添加现目录下的所有文件。</li>
<li>打一个轻量的无注释的标签。</li>
</ol>
<p><strong>创建一个主题分支并开发</strong><br>Create a topic branch and develop.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b alsa-audio &lt;1&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git checkout -- curses/ux_audio_oss.c &lt;2&gt;</div><div class="line">$ git add curses/ux_audio_alsa.c &lt;3&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git diff HEAD &lt;4&gt;</div><div class="line">$ git commit <span class="_">-a</span> <span class="_">-s</span> &lt;5&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git reset --soft HEAD^ &lt;6&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git diff ORIG_HEAD &lt;7&gt;</div><div class="line">$ git commit <span class="_">-a</span> -c ORIG_HEAD &lt;8&gt;</div><div class="line">$ git checkout master &lt;9&gt;</div><div class="line">$ git merge alsa-audio &lt;10&gt;</div><div class="line">$ git <span class="built_in">log</span> --since=<span class="string">'3 days ago'</span> &lt;11&gt;</div><div class="line">$ git <span class="built_in">log</span> v2.43.. curses/ &lt;12&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>创建(create)一个主题分支。</li>
<li>还原(revert)你在<code>curses/ux_audio_oss.c</code>文件里搞砸了的修改。</li>
<li>如果你添加一个新文件，你需要告诉git；之后，如果你使用<em><code>git commit -a</code></em>， 删除和修改就会被(git)捕获。</li>
<li>查看你正在提交什么修改。</li>
<li>提交所有的你已测试文件，包括你的签名。</li>
<li>撤回最后一次提交，保留工作区（working tree）内容。</li>
<li>查看自从上一个不成熟提交后的修改。</li>
<li>沿用原先写过的（注释）信息，重做在之前步骤中撤销了的提交。</li>
<li>切换到主干（master）分支。</li>
<li>合并一个主题分支到主分支。</li>
<li>回顾提交记录；其他限制输出的形式也可以合并包含（combined and include）： <em><code>--max-count=10</code></em>(显示10个提交)，<em><code>--until=2005-12-10</code></em> 等。</li>
<li>只查看从<em><code>v2.43</code></em>标签开始以来影响到<em><code>curses/</code></em>目录的修改。</li>
</ol>
<h2 id="个人开发者（参与开发）Individual-Developer-Participant"><a href="#个人开发者（参与开发）Individual-Developer-Participant" class="headerlink" title="个人开发者（参与开发）Individual Developer (Participant)"></a>个人开发者（参与开发）Individual Developer (Participant)</h2><p>作为一个团体项目里的参与角色，开发人员需要学习如何与他人沟通，除了那些单独开发者需要掌握的命令以外，还要使用这些命令。</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-clone.html" target="_blank" rel="external">git-clone(1)</a> 从上游代码库填充你的本地代码库。<br>from the upstream to prime your local repository.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-pull.html" target="_blank" rel="external">git-pull(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-fetch.html" target="_blank" rel="external">git-fetch(1)</a> 从“origin”得到最新的上游代码库。<br>from “origin” to keep up-to-date with the upstream.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-push.html" target="_blank" rel="external">git-push(1)</a> 共享代码库，如果你采用cvs风格的代码库工作流的话。<br>to shared repository, if you adopt CVS style shared repository workflow.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html" target="_blank" rel="external">git-format-patch(1)</a> 准备e-mail提交，如果你使用Linux内核风格的公共论坛工作流的话。<br>to prepare e-mail submission, if you adopt Linux kernel-style public forum workflow.</li>
</ul>
<h3 id="实例-Examples-1"><a href="#实例-Examples-1" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>复制上游代码库并在其上工作，提交修改到上游代码库。</strong><br>Clone the upstream and work on it. Feed changes to upstream.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/.../torvalds/linux-2.6 my2.6</div><div class="line">$ <span class="built_in">cd</span> my2.6</div><div class="line">$ edit/compile/<span class="built_in">test</span>; git commit <span class="_">-a</span> <span class="_">-s</span> &lt;1&gt;</div><div class="line">$ git format-patch origin &lt;2&gt;</div><div class="line">$ git pull &lt;3&gt;</div><div class="line">$ git <span class="built_in">log</span> -p ORIG_HEAD.. arch/i386 include/asm-i386 &lt;4&gt;</div><div class="line">$ git pull git://git.kernel.org/pub/.../jgarzik/libata-dev.git ALL &lt;5&gt;</div><div class="line">$ git reset --hard ORIG_HEAD &lt;6&gt;</div><div class="line">$ git gc &lt;7&gt;</div><div class="line">$ git fetch --tags &lt;8&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>按需重复。(repeat as needed)</li>
<li>从你的分支中提取补丁文件，用于电子邮件提交。</li>
<li><em><code>git pull</code></em>命令默认从“<em><code>origin</code></em>”里取得内容并合并到当前的分支中去。</li>
<li>在<code>pull</code>之后，立即查看在上游仓库中自上次检出之后提交的修改（日志），仅查看关注的部分。</li>
<li>从一个指定代码库的一个指定分支获取内容并合并。</li>
<li>撤销（revert）<code>pull</code>操作。</li>
<li>从撤销的<code>pull</code>操作中回收残存的对象。（代码库清理）</li>
<li>不时地，从<em><code>origin</code></em>中获取官方的标签，并保存于<em><code>.git/refs/tags/</code></em>。</li>
</ol>
<p><strong>推送到另一个代码库</strong><br>Push into another repository.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">satellite$ git <span class="built_in">clone</span> mothership:frotz frotz &lt;1&gt;</div><div class="line">satellite$ <span class="built_in">cd</span> frotz</div><div class="line">satellite$ git config --get-regexp <span class="string">'^(remote|branch)\.'</span> &lt;2&gt;</div><div class="line">remote.origin.url mothership:frotz</div><div class="line">remote.origin.fetch refs/heads/*:refs/remotes/origin/*</div><div class="line">branch.master.remote origin</div><div class="line">branch.master.merge refs/heads/master</div><div class="line">satellite$ git config remote.origin.push \</div><div class="line">           master:refs/remotes/satellite/master &lt;3&gt;</div><div class="line">satellite$ edit/compile/<span class="built_in">test</span>/commit</div><div class="line">satellite$ git push origin &lt;4&gt;</div><div class="line"></div><div class="line">mothership$ <span class="built_in">cd</span> frotz</div><div class="line">mothership$ git checkout master</div><div class="line">mothership$ git merge satellite/master &lt;5&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li><code>mothership</code>机器的<code>home</code>目录下有一个<code>frotz</code>代码库；复制它（clone from it）以在<code>satellite</code>机器上开始一个代码库。</li>
<li>复制（<code>clone</code>）操作默认设定这些配置变量。它安排<em><code>git pull</code></em>去抓取并保存<code>mothership</code>机器上的分支到本地的<em><code>remotes/origin/*</code></em> 跟踪分支。</li>
<li>安排<em><code>git push</code></em>去推送本地的主（<em><code>master</code></em>）分支到<code>mothership</code>机器的<em><code>remotes/satellite/master</code></em>分支</li>
<li><code>push</code>操作会在<code>mothership</code>机器的<em><code>remotes/satellite/master</code></em>的远程跟踪分支上存储我们的工作。你可以用此作为一个备份方法。</li>
<li>在<code>mothership</code>机器上，将<code>satellite</code>机器上已完成的工作合并到<code>master</code>分支中。</li>
</ol>
<p><strong>分支的特定标签</strong><br>Branch off of a specific tag.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b private2.6.14 v2.6.14 &lt;1&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span>; git commit <span class="_">-a</span></div><div class="line">$ git checkout master</div><div class="line">$ git format-patch -k -m --stdout v2.6.14..private2.6.14 |</div><div class="line">  git am -3 -k &lt;2&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>创建一个私有分支，基于熟知（但稍许过时的）标签。</li>
<li>在还没有正式“合并（merging）”的情况下，向前移植<code>private2.6.14</code>分支所有的修改到<code>master</code>分支上。</li>
</ol>
<h2 id="集成人员-Integrator"><a href="#集成人员-Integrator" class="headerlink" title="集成人员 Integrator"></a>集成人员 Integrator</h2><p>在一个团队项目中担任集成者的是一名相当重要的人员，他/她接收其他人的修改，评审并集成然后发布最终结果供其他人使用；除了参与者需要的那些命令之外，还需要使用以下这些命令。</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-am.html" target="_blank" rel="external">git-am(1)</a> 采用你的贡献者邮寄过来的补丁文件。<br>to apply patches e-mailed in from your contributors.*   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-pull.html" target="_blank" rel="external">git-pull(1)</a> 从你的可信任的助手处合并内容。<br>to merge from your trusted lieutenants.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html" target="_blank" rel="external">git-format-patch(1)</a> 准备并向你的贡献者发送建议选项。<br>to prepare and send suggested alternative to contributors.<em>   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-revert.html" target="_blank" rel="external">git-revert(1)</a> 撤销不好的提交。<br>to undo botched commits.</em>   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-push.html" target="_blank" rel="external">git-push(1)</a> 发布最新的内容。<br>to publish the bleeding edge.</li>
</ul>
<h3 id="实例-Examples-2"><a href="#实例-Examples-2" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>我典型的GIT一天</strong><br>My typical GIT day.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ git status &lt;1&gt;</div><div class="line">$ git show-branch &lt;2&gt;</div><div class="line">$ mailx &lt;3&gt;</div><div class="line">&amp; s 2 3 4 5 ./+to-apply</div><div class="line">&amp; s 7 8 ./+hold-linus</div><div class="line">&amp; q</div><div class="line">$ git checkout -b topic/one master</div><div class="line">$ git am -3 -i <span class="_">-s</span> -u ./+to-apply &lt;4&gt;</div><div class="line">$ compile/<span class="built_in">test</span></div><div class="line">$ git checkout -b hold/linus &amp;&amp; git am -3 -i <span class="_">-s</span> -u ./+hold-linus &lt;5&gt;</div><div class="line">$ git checkout topic/one &amp;&amp; git rebase master &lt;6&gt;</div><div class="line">$ git checkout pu &amp;&amp; git reset --hard next &lt;7&gt;</div><div class="line">$ git merge topic/one topic/two &amp;&amp; git merge hold/linus &lt;8&gt;</div><div class="line">$ git checkout maint</div><div class="line">$ git cherry-pick master~4 &lt;9&gt;</div><div class="line">$ compile/<span class="built_in">test</span></div><div class="line">$ git tag <span class="_">-s</span> -m <span class="string">"GIT 0.99.9x"</span> v0.99.9x &lt;10&gt;</div><div class="line">$ git fetch ko &amp;&amp; git show-branch master maint <span class="string">'tags/ko-*'</span> &lt;11&gt;</div><div class="line">$ git push ko &lt;12&gt;</div><div class="line">$ git push ko v0.99.9x &lt;13&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>查看我正在做什么，如果有的话。</li>
<li>查看我拥有的主题分支，并考虑它们的完成度。</li>
<li>读邮件，保存合适的，并且保存那些尚未完成的。</li>
<li>采用它们，交互式地，带着我的签名。</li>
<li>按需创建主题分支，还是由我签名采用。</li>
<li>为内部的还未合并到主分支，也没有作为稳定分支的一部分公开的主题分支重定基线。</li>
<li>从接下来开始，每次都重置<em>pu</em>。</li>
<li>合并仍然在料理中的主题分支</li>
<li>向后移植（backport）极其重要的修正。</li>
<li>创建一个签名的标签。</li>
<li>确保我不会意外将主分支回滚到我已经推出来的内容。简写的<em><code>ko</code></em>指向我在kernel.org上已有的代码库里，看起来像这样：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat .git/remotes/ko</div><div class="line">URL: kernel.org:/pub/scm/git/git.git</div><div class="line">Pull: master:refs/tags/ko-master</div><div class="line">Pull: next:refs/tags/ko-next</div><div class="line">Pull: maint:refs/tags/ko-maint</div><div class="line">Push: master</div><div class="line">Push: next</div><div class="line">Push: +pu</div><div class="line">Push: maint</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在从<em><code>git show-branch</code></em>的输出里，主分支（<em><code>master</code></em>）应该包含<em><code>ko-master</code></em>所有的内容，并且<em><code>next</code></em>应该包含<em><code>ko-next</code></em>所有的内容。<br>12.  推送最新内容<br>13.  推送标签</p>
<h2 id="代码库管理-Repository-Administration"><a href="#代码库管理-Repository-Administration" class="headerlink" title="代码库管理 Repository Administration"></a>代码库管理 Repository Administration</h2><p>代码库管理员使用下列工具来设置及维护开发者对代码库的访问。</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-daemon.html" target="_blank" rel="external">git-daemon(1)</a> 允许匿名者从代码库下载。<br>to allow anonymous download from repository.*   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-shell.html" target="_blank" rel="external">git-shell(1)</a> 可以被用作为限制登录shell，用于共享中央代码库的用户。<br>can be used as a <em>restricted login shell</em> for shared central repository users.<br><a href="https://www.kernel.org/pub/software/scm/git/docs/howto/update-hook-example.txt" target="_blank" rel="external">update hook howto</a> 有一个很好的管理共享中央代码库的实例。</li>
</ul>
<h3 id="实例-Examples-3"><a href="#实例-Examples-3" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>我们假设下面的内容均在/etc/services目录下</strong><br>We assume the following in /etc/services<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ grep 9418 /etc/services</div><div class="line">git             9418/tcp                <span class="comment"># Git Version Control System</span></div></pre></td></tr></table></figure></p>
<p><strong>从inetd中运行git-daemon来服务于/pub/scm</strong><br>Run git-daemon to serve /pub/scm from inetd.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ grep git /etc/inetd.conf</div><div class="line">git     stream  tcp     nowait  nobody \</div><div class="line">  /usr/bin/git-daemon git-daemon --inetd --export-all /pub/scm</div></pre></td></tr></table></figure></p>
<p>实际的配置应该在1行里。</p>
<p><strong>从xinetd运行git-daemon来服务于/pub/scm</strong><br>Run git-daemon to serve /pub/scm from xinetd.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/xinetd.d/git-daemon</div><div class="line"><span class="comment"># default: off</span></div><div class="line"><span class="comment"># description: The git server offers access to git repositories</span></div><div class="line">service git</div><div class="line">&#123;</div><div class="line">        <span class="built_in">disable</span> = no</div><div class="line">        <span class="built_in">type</span>            = UNLISTED</div><div class="line">        port            = 9418</div><div class="line">        socket_type     = stream</div><div class="line">        <span class="built_in">wait</span>            = no</div><div class="line">        user            = nobody</div><div class="line">        server          = /usr/bin/git-daemon</div><div class="line">        server_args     = --inetd --export-all --base-path=/pub/scm</div><div class="line">        log_on_failure  += USERID</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>检查<code>xinetd(8)</code>文档并设置，这个文档来自于Fedora系统。其他也许会不一样。</p>
<p><strong>授予开发者只推/拉访问操作权限</strong><br>Give push/pull only access to developers.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ grep git /etc/passwd &lt;1&gt;</div><div class="line">alice:x:1000:1000::/home/alice:/usr/bin/git-shell</div><div class="line">bob:x:1001:1001::/home/bob:/usr/bin/git-shell</div><div class="line">cindy:x:1002:1002::/home/cindy:/usr/bin/git-shell</div><div class="line">david:x:1003:1003::/home/david:/usr/bin/git-shell</div><div class="line">$ grep git /etc/shells &lt;2&gt;</div><div class="line">/usr/bin/git-shell</div></pre></td></tr></table></figure></p>
<ol>
<li>登录<code>shell</code>被设置到<code>/usr/bin/git-shell</code>, 不允许<em><code>git push</code></em>和<em><code>git pull</code></em>以外的任何操作。用户需要获得一个访问此机器的<code>ssh</code>权限。</li>
<li>在许多发布版本中，<code>/etc/shells</code>需要列出作为一个登录<code>shell</code>所使用的程序。</li>
</ol>
<p><strong>CVS风格的共享代码库</strong><br>CVS-style shared repository.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ grep git /etc/group &lt;1&gt;</div><div class="line">git:x:9418:alice,bob,cindy,david</div><div class="line">$ <span class="built_in">cd</span> /home/devo.git</div><div class="line">$ ls <span class="_">-l</span> &lt;2&gt;</div><div class="line">  lrwxrwxrwx   1 david git    17 Dec  4 22:40 HEAD -&gt; refs/heads/master</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 branches</div><div class="line">  -rw-rw-r--   1 david git    84 Dec  4 22:40 config</div><div class="line">  -rw-rw-r--   1 david git    58 Dec  4 22:40 description</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 hooks</div><div class="line">  -rw-rw-r--   1 david git 37504 Dec  4 22:40 index</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 info</div><div class="line">  drwxrwsr-x   4 david git  4096 Dec  4 22:40 objects</div><div class="line">  drwxrwsr-x   4 david git  4096 Nov  7 14:58 refs</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 remotes</div><div class="line">$ ls <span class="_">-l</span> hooks/update &lt;3&gt;</div><div class="line">  -r-xr-xr-x   1 david git  3536 Dec  4 22:40 update</div><div class="line">$ cat info/allowed-users &lt;4&gt;</div><div class="line">refs/heads/master       alice\|cindy</div><div class="line">refs/heads/doc-update   bob</div><div class="line">refs/tags/v[0-9]*       david</div></pre></td></tr></table></figure></p>
<ol>
<li>把开发者置于同一<code>git</code>组中。</li>
<li>将共享代码库配为组可写。</li>
<li>使用 Documentation/howto/ 中Carl的<code>update-hook</code>实例作为分支策略控制。</li>
<li>alice和cindy可以推送到主分支（master），只有bob可以推送进<code>doc-update</code>。david是发布经理，并且是唯一可以创建并推送版本标签的人。</li>
</ol>
<p><strong>支持dumb协议传送的HTTP服务器</strong><br>HTTP server to support dumb protocol transfer.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dev$ git update-server-info &lt;1&gt;</div><div class="line">dev$ ftp user@isp.example.com &lt;2&gt;</div><div class="line">ftp&gt; cp -r .git /home/user/myproject.git</div></pre></td></tr></table></figure></p>
<ol>
<li>确保你的 <code>info/refs</code> 和 <code>objects/info/packs</code> 是最新的。</li>
<li>上传到由你的ISP托管的公共HTTP服务器。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用git保存空目录]]></title>
      <url>http://jarsonfang.github.io/etesting/VCS/git-save-empty-dir/</url>
      <content type="html"><![CDATA[<p>git 和 svn 不同，仅仅跟踪文件的变动，不跟踪目录。Perforce 也是如此。所以，一个空目录，如果里面没有文件，即便 git add 这个目录，另外在别处 check out 的时候，是没有这个空目录的。</p>
<p>只跟踪文件变化，不跟踪目录，这么设计是有原因的。但这会带来一些小麻烦。有时候，确实需要在代码仓库中保留某个空目录。比如测试时需要用到的空目录。</p>
<p>变通的解决办法是在空目录下存一个 <code>.gitignore</code> 文件。然后 <code>git add</code> 此目录后，相当于跟踪了 <code>.gitignore</code> 文件，产生的“副作用”就是这个“空”目录也纳入“跟踪”，最终的效果是可以 check out 出一个看起来空空的目录。如果有许多这样的空目录，可以用下面的命令自动补充 <code>.gitignore</code> 文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find . \( -type d -empty \) -and \( -not -regex ./\.git.* \) -exec touch &#123;&#125;/.gitignore \;</div></pre></td></tr></table></figure></p>
<p>递归找寻当前目录下，类型为目录，且为空，也没有 <code>.git</code> 开头的文件，在其中用 touch 新建一个空的 <code>.gitignore</code> 文件。然后 <code>git add .</code> 之后即可。</p>
<p>如果这些特殊文件会对测试带来干扰，那就只好在测试程序运行具体测试项目之前，先跑一段初始化目录结构的代码。另外可能还需要编写负责清理的代码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>http://jarsonfang.github.io/etesting/VCS/git-in-common/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://www.cnblogs.com/1-2-3/archive/2010/07/18/git-commands.html" target="_blank" rel="external">http://www.cnblogs.com/1-2-3/archive/2010/07/18/git-commands.html</a></p>
<p>Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。</p>
<p><img src="/uploads/images/git_commands.png" alt="git_commands"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[caliper]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/Utility/caliper/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sysbench]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/Utility/sysbench/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Armor]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/Utility/armor/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenJDK]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/App/openjdk/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ceph]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/App/ceph/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ODP]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/App/odp/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hadoop]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/App/hadoop/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[KVM]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/virtualization/kvm/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xen]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/virtualization/xen/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenStack]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/virtualization/openstack/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/virtualization/docker/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LXC]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/virtualization/lxc/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[QEMU]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/virtualization/qemu/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LAMP]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/Server/lamp/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LNMP]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/Server/lnmp/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DNS]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/Server/dns/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DHCP]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/Server/dhcp/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[FTP on Centos 7]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/Server/ftp-on-centos/</url>
      <content type="html"><![CDATA[<p>In this article, we will learn how to configure FTP server on CentOs 7 using <code>vsftpd</code>. <code>vsftpd</code> (Very Secure File Transport Protocol Daemon) is a secure and very fast FTP server on Linux systems.</p>
<h2 id="Install-vsftpd"><a href="#Install-vsftpd" class="headerlink" title="Install vsftpd"></a>Install vsftpd</h2><p>All commands should be run with <code>root</code> user. Run the following command in terminal to install <code>vsftpd</code> package:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install vsftpd ftp -y</div></pre></td></tr></table></figure></p>
<h2 id="Configure-vsftpd"><a href="#Configure-vsftpd" class="headerlink" title="Configure vsftpd"></a>Configure vsftpd</h2><p>We needed to edit the configuration file <code>/etc/vsftpd/vsftpd.conf</code> for securing the FTP server since, by default it will allow anonymous users to login and use the server.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp /etc/vsftpd/vsftpd.conf&#123;,.bak&#125;</div><div class="line">vi /etc/vsftpd/vsftpd.conf</div></pre></td></tr></table></figure></p>
<p>We have to disallow anonymous, unidentified users to access files via FTP; change the anonymous_enable setting to NO:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">anonymous_enable=NO</div></pre></td></tr></table></figure></p>
<p>Allow local users to login by changing the local_enable setting to YES:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">local_enable=YES</div></pre></td></tr></table></figure></p>
<p>If you want to allow the local users to be able to write to a directory, then change the write_enable setting in the configuration file to YES:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">write_enable=YES</div></pre></td></tr></table></figure></p>
<p>Local users will be ‘chroot jailed’ and they will be denied access the local users to any other part of the server; change the chroot_local_user setting in the configuration file to YES:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chroot_local_user=YES</div></pre></td></tr></table></figure></p>
<p>Below is the simple configuration file for your reference:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">anonymous_enable=NO</div><div class="line">local_enable=YES</div><div class="line">write_enable=YES</div><div class="line">local_umask=022</div><div class="line">chroot_local_user=YES</div><div class="line">dirmessage_enable=YES</div><div class="line">xferlog_enable=YES</div><div class="line">connect_from_port_20=YES</div><div class="line">xferlog_std_format=YES</div><div class="line">listen=YES</div><div class="line">#listen_ipv6=YES</div><div class="line">pam_service_name=vsftpd</div><div class="line">userlist_enable=YES</div><div class="line">tcp_wrappers=YES</div></pre></td></tr></table></figure></p>
<h2 id="Enable-and-restart-the-vsftpd-service"><a href="#Enable-and-restart-the-vsftpd-service" class="headerlink" title="Enable and restart  the vsftpd service"></a>Enable and restart  the vsftpd service</h2><p>We needed to restart the <code>vsftpd</code> services so that the configuration changes has applied.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart vsftpd</div></pre></td></tr></table></figure></p>
<p>We will set the <code>vsftpd</code> service to start at boot time, below is the command to enable the <code>vsftpd</code> to start.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> vsftpd</div></pre></td></tr></table></figure></p>
<h2 id="Allowing-the-vsftpd-Through-the-Firewall"><a href="#Allowing-the-vsftpd-Through-the-Firewall" class="headerlink" title="Allowing the vsftpd Through the Firewall"></a>Allowing the vsftpd Through the Firewall</h2><p>Allow the ftp service and port <strong>21</strong> via firewall.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --permanent --add-port=21/tcp</div><div class="line">firewall-cmd --permanent --add-service=ftp</div></pre></td></tr></table></figure></p>
<p>Restart firewall:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure></p>
<h2 id="Create-FTP-users"><a href="#Create-FTP-users" class="headerlink" title="Create FTP users"></a>Create FTP users</h2><p>By default, root user is not allowed to login to ftp server for security purpose. So, let us create a normal testing user called “<code>ftpuser</code>” with password “centos”.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">useradd ftpuser</div><div class="line">passwd ftpuser</div></pre></td></tr></table></figure></p>
<h2 id="Connecting-to-FTP-server"><a href="#Connecting-to-FTP-server" class="headerlink" title="Connecting to FTP server"></a>Connecting to FTP server</h2><p>Now, try to connect to FTP server itself with user “<code>ftpuser</code>”:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftp 192.168.3.157</div></pre></td></tr></table></figure></p>
<p>Enter the ftp user name and password.<br>Note: change <code>192.168.3.157</code> with your own FTP server address.</p>
<p>Sample Output:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">onnected to 192.168.3.157.</div><div class="line">220 (vsFTPd 3.0.2)</div><div class="line">Name (192.168.3.157:jarson): ftpuser</div><div class="line">331 Please specify the password.</div><div class="line">Password:</div><div class="line">230 Login successful.</div><div class="line">Remote system <span class="built_in">type</span> is UNIX.</div><div class="line">Using binary mode to transfer files.</div><div class="line">ftp&gt;</div></pre></td></tr></table></figure></p>
<p>Congratulations! you will be able to login to FTP server without any problems.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]: <a href="http://www.tutorialspoint.com/articles/how-to-install-and-configuration-ftp-server-in-centos-7" target="_blank" rel="external">http://www.tutorialspoint.com/articles/how-to-install-and-configuration-ftp-server-in-centos-7</a><br>[2]: <a href="https://www.unixmen.com/install-configure-ftp-server-centos-7/" target="_blank" rel="external">https://www.unixmen.com/install-configure-ftp-server-centos-7/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Samba on Centos 7]]></title>
      <url>http://jarsonfang.github.io/etesting/testing/Server/samba-on-centos/</url>
      <content type="html"><![CDATA[<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install samba samba-client</div></pre></td></tr></table></figure>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>Now to configure samba, make the backup of original file as <code>/etc/samba/smb.conf.bak</code> before editing the file <code>/etc/samba/smb.conf</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp /etc/samba/smb.conf&#123;,.bak&#125;</div></pre></td></tr></table></figure>
<h3 id="Anonymous-samba-sharing"><a href="#Anonymous-samba-sharing" class="headerlink" title="Anonymous samba sharing"></a>Anonymous samba sharing</h3><p>Further give the entries like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;&gt; /etc/samba/smb.conf</div><div class="line">[share]</div><div class="line">    comment = Anonymous share</div><div class="line">    path = /srv/samba/share</div><div class="line">    public = yes</div><div class="line">    browsable =yes</div><div class="line">    writable = yes</div><div class="line">    guest ok = yes</div><div class="line">    <span class="built_in">read</span> only = no</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>Create the folder with the name <code>share</code> in the <code>/srv/samba</code> and give the permissions like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir -p /srv/samba/share</div><div class="line"><span class="built_in">cd</span> /srv/samba</div><div class="line">chmod -R 0755 share/</div><div class="line">chown -R nobody:nobody share/</div></pre></td></tr></table></figure></p>
<p>Restart samba service:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> smb.service</div><div class="line">systemctl restart smb.service</div></pre></td></tr></table></figure></p>
<p>Further, CentOS 7.0 Firewall-cmd will block the samba access, to get rid of that we will run:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --permanent --zone=public --add-service=samba</div><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure></p>
<h3 id="Secured-samba-server"><a href="#Secured-samba-server" class="headerlink" title="Secured samba server"></a>Secured samba server</h3><p>Therefore, create a group <code>smbgrp</code> &amp; user <code>smb</code> to access the samba server with proper authentication.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">groupadd smbgrp</div><div class="line">useradd smb -G smbgrp</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@cent-est samba]<span class="comment"># smbpasswd -a smb</span></div><div class="line">New SMB password:&lt;--yoursambapassword</div><div class="line">Retype new SMB password:&lt;--yoursambapassword</div><div class="line">Added user smb.</div><div class="line">[root@cent-est samba]<span class="comment">#</span></div></pre></td></tr></table></figure>
<p>Now create the folder with the name <code>secured</code> in the <code>/samba</code> folder and give permissions like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir -p /srv/samba/secured</div><div class="line"><span class="built_in">cd</span> /srv/samba</div><div class="line">chmod -R 0777 secured/</div><div class="line">chown -R smb:smbgrp secured/</div></pre></td></tr></table></figure></p>
<p>Again edit the configuration file as:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;&gt; /etc/samba/smb.conf</div><div class="line">[secured]</div><div class="line">    comment = Secured share</div><div class="line">    path = /srv/samba/secured</div><div class="line">    valid users = @smbgrp</div><div class="line">    guest ok = no</div><div class="line">    writable = yes</div><div class="line">    browsable = yes</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>Restart samba service:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart smb.service</div></pre></td></tr></table></figure></p>
<h3 id="Check-the-settings-as-follows"><a href="#Check-the-settings-as-follows" class="headerlink" title="Check the settings as follows:"></a>Check the settings as follows:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">[root@cent-est ~]<span class="comment"># testparm</span></div><div class="line">Load smb config files from /etc/samba/smb.conf</div><div class="line">rlimit_max: increasing rlimit_max (1024) to minimum Windows <span class="built_in">limit</span> (16384)</div><div class="line">Processing section <span class="string">"[homes]"</span></div><div class="line">Processing section <span class="string">"[printers]"</span></div><div class="line">Processing section <span class="string">"[share]"</span></div><div class="line">Processing section <span class="string">"[secured]"</span></div><div class="line">Loaded services file OK.</div><div class="line">Server role: ROLE_STANDALONE</div><div class="line"></div><div class="line">Press enter to see a dump of your service definitions</div><div class="line"></div><div class="line"><span class="comment"># Global parameters</span></div><div class="line">[global]</div><div class="line">        workgroup = MYGROUP</div><div class="line">        server string = Samba Server Version %v</div><div class="line">        security = USER</div><div class="line">        <span class="built_in">log</span> file = /var/<span class="built_in">log</span>/samba/log.%m</div><div class="line">        max <span class="built_in">log</span> size = 50</div><div class="line">        idmap config * : backend = tdb</div><div class="line">        cups options = raw</div><div class="line"></div><div class="line"></div><div class="line">[homes]</div><div class="line">        comment = Home Directories</div><div class="line">        <span class="built_in">read</span> only = No</div><div class="line">        browseable = No</div><div class="line"></div><div class="line"></div><div class="line">[printers]</div><div class="line">        comment = All Printers</div><div class="line">        path = /var/spool/samba</div><div class="line">        printable = Yes</div><div class="line">        <span class="built_in">print</span> ok = Yes</div><div class="line">        browseable = No</div><div class="line"></div><div class="line"></div><div class="line">[share]</div><div class="line">        comment = Anonymous share</div><div class="line">        path = /srv/samba/share</div><div class="line">        <span class="built_in">read</span> only = No</div><div class="line">        guest ok = Yes</div><div class="line"></div><div class="line"></div><div class="line">[secured]</div><div class="line">        comment = Secured share</div><div class="line">        path = /srv/samba/secured</div><div class="line">        valid users = @smbgrp</div><div class="line">        <span class="built_in">read</span> only = No</div><div class="line">[root@cent-est ~]<span class="comment">#</span></div></pre></td></tr></table></figure>
<h2 id="Test-with-smbclient"><a href="#Test-with-smbclient" class="headerlink" title="Test with smbclient"></a>Test with smbclient</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[root@cent-est ~]# smbclient //localhost/share -U user</div><div class="line">Enter user&apos;s password:&lt;--Enter</div><div class="line">Anonymous login successful</div><div class="line">Domain=[MYGROUP] OS=[Windows 6.1] Server=[Samba 4.2.10]</div><div class="line">smb: \&gt; ls</div><div class="line">  .                                   D        0  Thu Sep 29 15:06:51 2016</div><div class="line">  ..                                  D        0  Thu Sep 29 14:25:32 2016</div><div class="line">  hello.txt                           N        0  Thu Sep 29 15:06:51 2016</div><div class="line"></div><div class="line">                51475068 blocks of size 1024. 37599412 blocks available</div><div class="line">smb: \&gt; exit</div><div class="line">[root@cent-est ~]#</div><div class="line">[root@cent-est ~]# smbclient //localhost/secured -U user</div><div class="line">Enter user&apos;s password:&lt;--Enter</div><div class="line">Anonymous login successful</div><div class="line">Domain=[MYGROUP] OS=[Windows 6.1] Server=[Samba 4.2.10]</div><div class="line">tree connect failed: NT_STATUS_ACCESS_DENIED</div><div class="line">[root@cent-est ~]#</div><div class="line">[root@cent-est ~]# smbclient //localhost/secured -U smb</div><div class="line">Enter smb&apos;s password:</div><div class="line">Domain=[MYGROUP] OS=[Windows 6.1] Server=[Samba 4.2.10]</div><div class="line">smb: \&gt; ls</div><div class="line">  .                                   D        0  Thu Sep 29 15:06:42 2016</div><div class="line">  ..                                  D        0  Thu Sep 29 14:25:32 2016</div><div class="line">  file.txt                            N        0  Thu Sep 29 15:06:42 2016</div><div class="line"></div><div class="line">                51475068 blocks of size 1024. 37599408 blocks available</div><div class="line">smb: \&gt; exit</div><div class="line">[root@cent-est ~]#</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]: <a href="https://www.howtoforge.com/samba-server-installation-and-configuration-on-centos-7" target="_blank" rel="external">https://www.howtoforge.com/samba-server-installation-and-configuration-on-centos-7</a><br>[2]: <a href="https://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/" target="_blank" rel="external">https://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://jarsonfang.github.io/etesting/Hexo/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
